// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/scalar"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Connection() ConnectionResolver
	ConnectionMutation() ConnectionMutationResolver
	ConnectionQuery() ConnectionQueryResolver
	FileQuery() FileQueryResolver
	ImportMutation() ImportMutationResolver
	Job() JobResolver
	JobLog() JobLogResolver
	JobQuery() JobQueryResolver
	LogQuery() LogQueryResolver
	Mutation() MutationResolver
	ProviderQuery() ProviderQueryResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	Task() TaskResolver
	TaskMutation() TaskMutationResolver
	TaskQuery() TaskQueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Connection struct {
		Config     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		LoadError  func(childComplexity int) int
		LoadStatus func(childComplexity int) int
		Name       func(childComplexity int) int
		Quota      func(childComplexity int) int
		Tasks      func(childComplexity int, pagination *model.PaginationInput) int
		Type       func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	ConnectionConnection struct {
		Items      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConnectionMutation struct {
		Create      func(childComplexity int, input model.CreateConnectionInput) int
		Delete      func(childComplexity int, id uuid.UUID) int
		Test        func(childComplexity int, id uuid.UUID) int
		TestUnsaved func(childComplexity int, input model.TestConnectionInput) int
		Update      func(childComplexity int, id uuid.UUID, input model.UpdateConnectionInput) int
	}

	ConnectionQuery struct {
		Get  func(childComplexity int, id uuid.UUID) int
		List func(childComplexity int, pagination *model.PaginationInput) int
	}

	ConnectionQuota struct {
		Free    func(childComplexity int) int
		Objects func(childComplexity int) int
		Other   func(childComplexity int) int
		Total   func(childComplexity int) int
		Trashed func(childComplexity int) int
		Used    func(childComplexity int) int
	}

	ConnectionTestFailure struct {
		Error func(childComplexity int) int
	}

	ConnectionTestSuccess struct {
		Message func(childComplexity int) int
	}

	FileEntry struct {
		IsDir func(childComplexity int) int
		Name  func(childComplexity int) int
		Path  func(childComplexity int) int
	}

	FileQuery struct {
		Local  func(childComplexity int, path string) int
		Remote func(childComplexity int, connectionID uuid.UUID, path string) int
	}

	ImportExecuteResult struct {
		Connections  func(childComplexity int) int
		SkippedCount func(childComplexity int) int
	}

	ImportMutation struct {
		Execute func(childComplexity int, input model.ImportExecuteInput) int
		Parse   func(childComplexity int, input model.ImportParseInput) int
	}

	ImportParseError struct {
		Error func(childComplexity int) int
		Line  func(childComplexity int) int
	}

	ImportParseSuccess struct {
		Connections func(childComplexity int) int
	}

	Job struct {
		BytesTransferred func(childComplexity int) int
		EndTime          func(childComplexity int) int
		ErrorCount       func(childComplexity int) int
		Errors           func(childComplexity int) int
		FilesDeleted     func(childComplexity int) int
		FilesTransferred func(childComplexity int) int
		ID               func(childComplexity int) int
		Logs             func(childComplexity int, pagination *model.PaginationInput) int
		Progress         func(childComplexity int) int
		StartTime        func(childComplexity int) int
		Status           func(childComplexity int) int
		Task             func(childComplexity int) int
		Trigger          func(childComplexity int) int
	}

	JobConnection struct {
		Items      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	JobLog struct {
		ID    func(childComplexity int) int
		Job   func(childComplexity int) int
		Level func(childComplexity int) int
		Path  func(childComplexity int) int
		Size  func(childComplexity int) int
		Time  func(childComplexity int) int
		What  func(childComplexity int) int
	}

	JobLogConnection struct {
		Items      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	JobProgressEvent struct {
		BytesTotal       func(childComplexity int) int
		BytesTransferred func(childComplexity int) int
		ConnectionID     func(childComplexity int) int
		EndTime          func(childComplexity int) int
		ErrorCount       func(childComplexity int) int
		FilesDeleted     func(childComplexity int) int
		FilesTotal       func(childComplexity int) int
		FilesTransferred func(childComplexity int) int
		JobID            func(childComplexity int) int
		StartTime        func(childComplexity int) int
		Status           func(childComplexity int) int
		TaskID           func(childComplexity int) int
	}

	JobQuery struct {
		Get      func(childComplexity int, id uuid.UUID) int
		List     func(childComplexity int, taskID *uuid.UUID, connectionID *uuid.UUID, pagination *model.PaginationInput) int
		Progress func(childComplexity int, id uuid.UUID) int
	}

	LogQuery struct {
		List func(childComplexity int, connectionID uuid.UUID, taskID *uuid.UUID, jobID *uuid.UUID, level *model.LogLevel, pagination *model.PaginationInput) int
	}

	Mutation struct {
		Connection func(childComplexity int) int
		Import     func(childComplexity int) int
		Task       func(childComplexity int) int
	}

	OffsetPageInfo struct {
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		Limit           func(childComplexity int) int
		Offset          func(childComplexity int) int
	}

	OptionExample struct {
		Help  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ParsedConnection struct {
		Config func(childComplexity int) int
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	Provider struct {
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
		Options     func(childComplexity int) int
		Prefix      func(childComplexity int) int
	}

	ProviderOption struct {
		Advanced   func(childComplexity int) int
		Default    func(childComplexity int) int
		Examples   func(childComplexity int) int
		Exclusive  func(childComplexity int) int
		Groups     func(childComplexity int) int
		Help       func(childComplexity int) int
		IsPassword func(childComplexity int) int
		Name       func(childComplexity int) int
		Required   func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	ProviderQuery struct {
		Get  func(childComplexity int, name string) int
		List func(childComplexity int) int
	}

	Query struct {
		Connection func(childComplexity int) int
		File       func(childComplexity int) int
		Job        func(childComplexity int) int
		Log        func(childComplexity int) int
		Provider   func(childComplexity int) int
		Task       func(childComplexity int) int
	}

	Subscription struct {
		JobProgress      func(childComplexity int, taskID *uuid.UUID, connectionID *uuid.UUID) int
		TransferProgress func(childComplexity int, connectionID *uuid.UUID, taskID *uuid.UUID, jobID *uuid.UUID) int
	}

	Task struct {
		Connection func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Direction  func(childComplexity int) int
		ID         func(childComplexity int) int
		Jobs       func(childComplexity int, pagination *model.PaginationInput) int
		LatestJob  func(childComplexity int) int
		Name       func(childComplexity int) int
		Options    func(childComplexity int) int
		Realtime   func(childComplexity int) int
		RemotePath func(childComplexity int) int
		Schedule   func(childComplexity int) int
		SourcePath func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	TaskConnection struct {
		Items      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskMutation struct {
		Create func(childComplexity int, input model.CreateTaskInput) int
		Delete func(childComplexity int, id uuid.UUID) int
		Run    func(childComplexity int, taskID uuid.UUID) int
		Update func(childComplexity int, id uuid.UUID, input model.UpdateTaskInput) int
	}

	TaskQuery struct {
		Get  func(childComplexity int, id uuid.UUID) int
		List func(childComplexity int, pagination *model.PaginationInput) int
	}

	TaskSyncOptions struct {
		ConflictResolution func(childComplexity int) int
	}

	TransferItem struct {
		Bytes func(childComplexity int) int
		Name  func(childComplexity int) int
		Size  func(childComplexity int) int
	}

	TransferProgressEvent struct {
		ConnectionID func(childComplexity int) int
		JobID        func(childComplexity int) int
		TaskID       func(childComplexity int) int
		Transfers    func(childComplexity int) int
	}
}

type ConnectionResolver interface {
	Config(ctx context.Context, obj *model.Connection) (map[string]string, error)
	LoadStatus(ctx context.Context, obj *model.Connection) (model.ConnectionLoadStatus, error)
	LoadError(ctx context.Context, obj *model.Connection) (*string, error)

	Tasks(ctx context.Context, obj *model.Connection, pagination *model.PaginationInput) (*model.TaskConnection, error)
	Quota(ctx context.Context, obj *model.Connection) (*model.ConnectionQuota, error)
}
type ConnectionMutationResolver interface {
	Create(ctx context.Context, obj *model.ConnectionMutation, input model.CreateConnectionInput) (*model.Connection, error)
	Update(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID, input model.UpdateConnectionInput) (*model.Connection, error)
	Delete(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID) (*model.Connection, error)
	Test(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID) (model.TestConnectionResult, error)
	TestUnsaved(ctx context.Context, obj *model.ConnectionMutation, input model.TestConnectionInput) (model.TestConnectionResult, error)
}
type ConnectionQueryResolver interface {
	List(ctx context.Context, obj *model.ConnectionQuery, pagination *model.PaginationInput) (*model.ConnectionConnection, error)
	Get(ctx context.Context, obj *model.ConnectionQuery, id uuid.UUID) (*model.Connection, error)
}
type FileQueryResolver interface {
	Local(ctx context.Context, obj *model.FileQuery, path string) ([]*model.FileEntry, error)
	Remote(ctx context.Context, obj *model.FileQuery, connectionID uuid.UUID, path string) ([]*model.FileEntry, error)
}
type ImportMutationResolver interface {
	Parse(ctx context.Context, obj *model.ImportMutation, input model.ImportParseInput) (model.ImportParseResult, error)
	Execute(ctx context.Context, obj *model.ImportMutation, input model.ImportExecuteInput) (*model.ImportExecuteResult, error)
}
type JobResolver interface {
	Task(ctx context.Context, obj *model.Job) (*model.Task, error)
	Logs(ctx context.Context, obj *model.Job, pagination *model.PaginationInput) (*model.JobLogConnection, error)
	Progress(ctx context.Context, obj *model.Job) (*model.JobProgressEvent, error)
}
type JobLogResolver interface {
	Job(ctx context.Context, obj *model.JobLog) (*model.Job, error)
}
type JobQueryResolver interface {
	List(ctx context.Context, obj *model.JobQuery, taskID *uuid.UUID, connectionID *uuid.UUID, pagination *model.PaginationInput) (*model.JobConnection, error)

	Progress(ctx context.Context, obj *model.JobQuery, id uuid.UUID) (*model.JobProgressEvent, error)
}
type LogQueryResolver interface {
	List(ctx context.Context, obj *model.LogQuery, connectionID uuid.UUID, taskID *uuid.UUID, jobID *uuid.UUID, level *model.LogLevel, pagination *model.PaginationInput) (*model.JobLogConnection, error)
}
type MutationResolver interface {
	Connection(ctx context.Context) (*model.ConnectionMutation, error)
	Import(ctx context.Context) (*model.ImportMutation, error)
	Task(ctx context.Context) (*model.TaskMutation, error)
}
type ProviderQueryResolver interface {
	List(ctx context.Context, obj *model.ProviderQuery) ([]*model.Provider, error)
	Get(ctx context.Context, obj *model.ProviderQuery, name string) (*model.Provider, error)
}
type QueryResolver interface {
	Connection(ctx context.Context) (*model.ConnectionQuery, error)
	File(ctx context.Context) (*model.FileQuery, error)
	Job(ctx context.Context) (*model.JobQuery, error)
	Log(ctx context.Context) (*model.LogQuery, error)
	Provider(ctx context.Context) (*model.ProviderQuery, error)
	Task(ctx context.Context) (*model.TaskQuery, error)
}
type SubscriptionResolver interface {
	JobProgress(ctx context.Context, taskID *uuid.UUID, connectionID *uuid.UUID) (<-chan *model.JobProgressEvent, error)
	TransferProgress(ctx context.Context, connectionID *uuid.UUID, taskID *uuid.UUID, jobID *uuid.UUID) (<-chan *model.TransferProgressEvent, error)
}
type TaskResolver interface {
	Options(ctx context.Context, obj *model.Task) (*model.TaskSyncOptions, error)

	Connection(ctx context.Context, obj *model.Task) (*model.Connection, error)
	Jobs(ctx context.Context, obj *model.Task, pagination *model.PaginationInput) (*model.JobConnection, error)
	LatestJob(ctx context.Context, obj *model.Task) (*model.Job, error)
}
type TaskMutationResolver interface {
	Create(ctx context.Context, obj *model.TaskMutation, input model.CreateTaskInput) (*model.Task, error)
	Update(ctx context.Context, obj *model.TaskMutation, id uuid.UUID, input model.UpdateTaskInput) (*model.Task, error)
	Delete(ctx context.Context, obj *model.TaskMutation, id uuid.UUID) (*model.Task, error)
	Run(ctx context.Context, obj *model.TaskMutation, taskID uuid.UUID) (*model.Job, error)
}
type TaskQueryResolver interface {
	List(ctx context.Context, obj *model.TaskQuery, pagination *model.PaginationInput) (*model.TaskConnection, error)
	Get(ctx context.Context, obj *model.TaskQuery, id uuid.UUID) (*model.Task, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Connection.config":
		if e.complexity.Connection.Config == nil {
			break
		}

		return e.complexity.Connection.Config(childComplexity), true
	case "Connection.createdAt":
		if e.complexity.Connection.CreatedAt == nil {
			break
		}

		return e.complexity.Connection.CreatedAt(childComplexity), true
	case "Connection.id":
		if e.complexity.Connection.ID == nil {
			break
		}

		return e.complexity.Connection.ID(childComplexity), true
	case "Connection.loadError":
		if e.complexity.Connection.LoadError == nil {
			break
		}

		return e.complexity.Connection.LoadError(childComplexity), true
	case "Connection.loadStatus":
		if e.complexity.Connection.LoadStatus == nil {
			break
		}

		return e.complexity.Connection.LoadStatus(childComplexity), true
	case "Connection.name":
		if e.complexity.Connection.Name == nil {
			break
		}

		return e.complexity.Connection.Name(childComplexity), true
	case "Connection.quota":
		if e.complexity.Connection.Quota == nil {
			break
		}

		return e.complexity.Connection.Quota(childComplexity), true
	case "Connection.tasks":
		if e.complexity.Connection.Tasks == nil {
			break
		}

		args, err := ec.field_Connection_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Connection.Tasks(childComplexity, args["pagination"].(*model.PaginationInput)), true
	case "Connection.type":
		if e.complexity.Connection.Type == nil {
			break
		}

		return e.complexity.Connection.Type(childComplexity), true
	case "Connection.updatedAt":
		if e.complexity.Connection.UpdatedAt == nil {
			break
		}

		return e.complexity.Connection.UpdatedAt(childComplexity), true

	case "ConnectionConnection.items":
		if e.complexity.ConnectionConnection.Items == nil {
			break
		}

		return e.complexity.ConnectionConnection.Items(childComplexity), true
	case "ConnectionConnection.pageInfo":
		if e.complexity.ConnectionConnection.PageInfo == nil {
			break
		}

		return e.complexity.ConnectionConnection.PageInfo(childComplexity), true
	case "ConnectionConnection.totalCount":
		if e.complexity.ConnectionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ConnectionConnection.TotalCount(childComplexity), true

	case "ConnectionMutation.create":
		if e.complexity.ConnectionMutation.Create == nil {
			break
		}

		args, err := ec.field_ConnectionMutation_create_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionMutation.Create(childComplexity, args["input"].(model.CreateConnectionInput)), true
	case "ConnectionMutation.delete":
		if e.complexity.ConnectionMutation.Delete == nil {
			break
		}

		args, err := ec.field_ConnectionMutation_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionMutation.Delete(childComplexity, args["id"].(uuid.UUID)), true
	case "ConnectionMutation.test":
		if e.complexity.ConnectionMutation.Test == nil {
			break
		}

		args, err := ec.field_ConnectionMutation_test_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionMutation.Test(childComplexity, args["id"].(uuid.UUID)), true
	case "ConnectionMutation.testUnsaved":
		if e.complexity.ConnectionMutation.TestUnsaved == nil {
			break
		}

		args, err := ec.field_ConnectionMutation_testUnsaved_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionMutation.TestUnsaved(childComplexity, args["input"].(model.TestConnectionInput)), true
	case "ConnectionMutation.update":
		if e.complexity.ConnectionMutation.Update == nil {
			break
		}

		args, err := ec.field_ConnectionMutation_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionMutation.Update(childComplexity, args["id"].(uuid.UUID), args["input"].(model.UpdateConnectionInput)), true

	case "ConnectionQuery.get":
		if e.complexity.ConnectionQuery.Get == nil {
			break
		}

		args, err := ec.field_ConnectionQuery_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionQuery.Get(childComplexity, args["id"].(uuid.UUID)), true
	case "ConnectionQuery.list":
		if e.complexity.ConnectionQuery.List == nil {
			break
		}

		args, err := ec.field_ConnectionQuery_list_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ConnectionQuery.List(childComplexity, args["pagination"].(*model.PaginationInput)), true

	case "ConnectionQuota.free":
		if e.complexity.ConnectionQuota.Free == nil {
			break
		}

		return e.complexity.ConnectionQuota.Free(childComplexity), true
	case "ConnectionQuota.objects":
		if e.complexity.ConnectionQuota.Objects == nil {
			break
		}

		return e.complexity.ConnectionQuota.Objects(childComplexity), true
	case "ConnectionQuota.other":
		if e.complexity.ConnectionQuota.Other == nil {
			break
		}

		return e.complexity.ConnectionQuota.Other(childComplexity), true
	case "ConnectionQuota.total":
		if e.complexity.ConnectionQuota.Total == nil {
			break
		}

		return e.complexity.ConnectionQuota.Total(childComplexity), true
	case "ConnectionQuota.trashed":
		if e.complexity.ConnectionQuota.Trashed == nil {
			break
		}

		return e.complexity.ConnectionQuota.Trashed(childComplexity), true
	case "ConnectionQuota.used":
		if e.complexity.ConnectionQuota.Used == nil {
			break
		}

		return e.complexity.ConnectionQuota.Used(childComplexity), true

	case "ConnectionTestFailure.error":
		if e.complexity.ConnectionTestFailure.Error == nil {
			break
		}

		return e.complexity.ConnectionTestFailure.Error(childComplexity), true

	case "ConnectionTestSuccess.message":
		if e.complexity.ConnectionTestSuccess.Message == nil {
			break
		}

		return e.complexity.ConnectionTestSuccess.Message(childComplexity), true

	case "FileEntry.isDir":
		if e.complexity.FileEntry.IsDir == nil {
			break
		}

		return e.complexity.FileEntry.IsDir(childComplexity), true
	case "FileEntry.name":
		if e.complexity.FileEntry.Name == nil {
			break
		}

		return e.complexity.FileEntry.Name(childComplexity), true
	case "FileEntry.path":
		if e.complexity.FileEntry.Path == nil {
			break
		}

		return e.complexity.FileEntry.Path(childComplexity), true

	case "FileQuery.local":
		if e.complexity.FileQuery.Local == nil {
			break
		}

		args, err := ec.field_FileQuery_local_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FileQuery.Local(childComplexity, args["path"].(string)), true
	case "FileQuery.remote":
		if e.complexity.FileQuery.Remote == nil {
			break
		}

		args, err := ec.field_FileQuery_remote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FileQuery.Remote(childComplexity, args["connectionId"].(uuid.UUID), args["path"].(string)), true

	case "ImportExecuteResult.connections":
		if e.complexity.ImportExecuteResult.Connections == nil {
			break
		}

		return e.complexity.ImportExecuteResult.Connections(childComplexity), true
	case "ImportExecuteResult.skippedCount":
		if e.complexity.ImportExecuteResult.SkippedCount == nil {
			break
		}

		return e.complexity.ImportExecuteResult.SkippedCount(childComplexity), true

	case "ImportMutation.execute":
		if e.complexity.ImportMutation.Execute == nil {
			break
		}

		args, err := ec.field_ImportMutation_execute_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImportMutation.Execute(childComplexity, args["input"].(model.ImportExecuteInput)), true
	case "ImportMutation.parse":
		if e.complexity.ImportMutation.Parse == nil {
			break
		}

		args, err := ec.field_ImportMutation_parse_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ImportMutation.Parse(childComplexity, args["input"].(model.ImportParseInput)), true

	case "ImportParseError.error":
		if e.complexity.ImportParseError.Error == nil {
			break
		}

		return e.complexity.ImportParseError.Error(childComplexity), true
	case "ImportParseError.line":
		if e.complexity.ImportParseError.Line == nil {
			break
		}

		return e.complexity.ImportParseError.Line(childComplexity), true

	case "ImportParseSuccess.connections":
		if e.complexity.ImportParseSuccess.Connections == nil {
			break
		}

		return e.complexity.ImportParseSuccess.Connections(childComplexity), true

	case "Job.bytesTransferred":
		if e.complexity.Job.BytesTransferred == nil {
			break
		}

		return e.complexity.Job.BytesTransferred(childComplexity), true
	case "Job.endTime":
		if e.complexity.Job.EndTime == nil {
			break
		}

		return e.complexity.Job.EndTime(childComplexity), true
	case "Job.errorCount":
		if e.complexity.Job.ErrorCount == nil {
			break
		}

		return e.complexity.Job.ErrorCount(childComplexity), true
	case "Job.errors":
		if e.complexity.Job.Errors == nil {
			break
		}

		return e.complexity.Job.Errors(childComplexity), true
	case "Job.filesDeleted":
		if e.complexity.Job.FilesDeleted == nil {
			break
		}

		return e.complexity.Job.FilesDeleted(childComplexity), true
	case "Job.filesTransferred":
		if e.complexity.Job.FilesTransferred == nil {
			break
		}

		return e.complexity.Job.FilesTransferred(childComplexity), true
	case "Job.id":
		if e.complexity.Job.ID == nil {
			break
		}

		return e.complexity.Job.ID(childComplexity), true
	case "Job.logs":
		if e.complexity.Job.Logs == nil {
			break
		}

		args, err := ec.field_Job_logs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Job.Logs(childComplexity, args["pagination"].(*model.PaginationInput)), true
	case "Job.progress":
		if e.complexity.Job.Progress == nil {
			break
		}

		return e.complexity.Job.Progress(childComplexity), true
	case "Job.startTime":
		if e.complexity.Job.StartTime == nil {
			break
		}

		return e.complexity.Job.StartTime(childComplexity), true
	case "Job.status":
		if e.complexity.Job.Status == nil {
			break
		}

		return e.complexity.Job.Status(childComplexity), true
	case "Job.task":
		if e.complexity.Job.Task == nil {
			break
		}

		return e.complexity.Job.Task(childComplexity), true
	case "Job.trigger":
		if e.complexity.Job.Trigger == nil {
			break
		}

		return e.complexity.Job.Trigger(childComplexity), true

	case "JobConnection.items":
		if e.complexity.JobConnection.Items == nil {
			break
		}

		return e.complexity.JobConnection.Items(childComplexity), true
	case "JobConnection.pageInfo":
		if e.complexity.JobConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobConnection.PageInfo(childComplexity), true
	case "JobConnection.totalCount":
		if e.complexity.JobConnection.TotalCount == nil {
			break
		}

		return e.complexity.JobConnection.TotalCount(childComplexity), true

	case "JobLog.id":
		if e.complexity.JobLog.ID == nil {
			break
		}

		return e.complexity.JobLog.ID(childComplexity), true
	case "JobLog.job":
		if e.complexity.JobLog.Job == nil {
			break
		}

		return e.complexity.JobLog.Job(childComplexity), true
	case "JobLog.level":
		if e.complexity.JobLog.Level == nil {
			break
		}

		return e.complexity.JobLog.Level(childComplexity), true
	case "JobLog.path":
		if e.complexity.JobLog.Path == nil {
			break
		}

		return e.complexity.JobLog.Path(childComplexity), true
	case "JobLog.size":
		if e.complexity.JobLog.Size == nil {
			break
		}

		return e.complexity.JobLog.Size(childComplexity), true
	case "JobLog.time":
		if e.complexity.JobLog.Time == nil {
			break
		}

		return e.complexity.JobLog.Time(childComplexity), true
	case "JobLog.what":
		if e.complexity.JobLog.What == nil {
			break
		}

		return e.complexity.JobLog.What(childComplexity), true

	case "JobLogConnection.items":
		if e.complexity.JobLogConnection.Items == nil {
			break
		}

		return e.complexity.JobLogConnection.Items(childComplexity), true
	case "JobLogConnection.pageInfo":
		if e.complexity.JobLogConnection.PageInfo == nil {
			break
		}

		return e.complexity.JobLogConnection.PageInfo(childComplexity), true
	case "JobLogConnection.totalCount":
		if e.complexity.JobLogConnection.TotalCount == nil {
			break
		}

		return e.complexity.JobLogConnection.TotalCount(childComplexity), true

	case "JobProgressEvent.bytesTotal":
		if e.complexity.JobProgressEvent.BytesTotal == nil {
			break
		}

		return e.complexity.JobProgressEvent.BytesTotal(childComplexity), true
	case "JobProgressEvent.bytesTransferred":
		if e.complexity.JobProgressEvent.BytesTransferred == nil {
			break
		}

		return e.complexity.JobProgressEvent.BytesTransferred(childComplexity), true
	case "JobProgressEvent.connectionId":
		if e.complexity.JobProgressEvent.ConnectionID == nil {
			break
		}

		return e.complexity.JobProgressEvent.ConnectionID(childComplexity), true
	case "JobProgressEvent.endTime":
		if e.complexity.JobProgressEvent.EndTime == nil {
			break
		}

		return e.complexity.JobProgressEvent.EndTime(childComplexity), true
	case "JobProgressEvent.errorCount":
		if e.complexity.JobProgressEvent.ErrorCount == nil {
			break
		}

		return e.complexity.JobProgressEvent.ErrorCount(childComplexity), true
	case "JobProgressEvent.filesDeleted":
		if e.complexity.JobProgressEvent.FilesDeleted == nil {
			break
		}

		return e.complexity.JobProgressEvent.FilesDeleted(childComplexity), true
	case "JobProgressEvent.filesTotal":
		if e.complexity.JobProgressEvent.FilesTotal == nil {
			break
		}

		return e.complexity.JobProgressEvent.FilesTotal(childComplexity), true
	case "JobProgressEvent.filesTransferred":
		if e.complexity.JobProgressEvent.FilesTransferred == nil {
			break
		}

		return e.complexity.JobProgressEvent.FilesTransferred(childComplexity), true
	case "JobProgressEvent.jobId":
		if e.complexity.JobProgressEvent.JobID == nil {
			break
		}

		return e.complexity.JobProgressEvent.JobID(childComplexity), true
	case "JobProgressEvent.startTime":
		if e.complexity.JobProgressEvent.StartTime == nil {
			break
		}

		return e.complexity.JobProgressEvent.StartTime(childComplexity), true
	case "JobProgressEvent.status":
		if e.complexity.JobProgressEvent.Status == nil {
			break
		}

		return e.complexity.JobProgressEvent.Status(childComplexity), true
	case "JobProgressEvent.taskId":
		if e.complexity.JobProgressEvent.TaskID == nil {
			break
		}

		return e.complexity.JobProgressEvent.TaskID(childComplexity), true

	case "JobQuery.get":
		if e.complexity.JobQuery.Get == nil {
			break
		}

		args, err := ec.field_JobQuery_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.JobQuery.Get(childComplexity, args["id"].(uuid.UUID)), true
	case "JobQuery.list":
		if e.complexity.JobQuery.List == nil {
			break
		}

		args, err := ec.field_JobQuery_list_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.JobQuery.List(childComplexity, args["taskId"].(*uuid.UUID), args["connectionId"].(*uuid.UUID), args["pagination"].(*model.PaginationInput)), true
	case "JobQuery.progress":
		if e.complexity.JobQuery.Progress == nil {
			break
		}

		args, err := ec.field_JobQuery_progress_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.JobQuery.Progress(childComplexity, args["id"].(uuid.UUID)), true

	case "LogQuery.list":
		if e.complexity.LogQuery.List == nil {
			break
		}

		args, err := ec.field_LogQuery_list_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LogQuery.List(childComplexity, args["connectionId"].(uuid.UUID), args["taskId"].(*uuid.UUID), args["jobId"].(*uuid.UUID), args["level"].(*model.LogLevel), args["pagination"].(*model.PaginationInput)), true

	case "Mutation.connection":
		if e.complexity.Mutation.Connection == nil {
			break
		}

		return e.complexity.Mutation.Connection(childComplexity), true
	case "Mutation.import":
		if e.complexity.Mutation.Import == nil {
			break
		}

		return e.complexity.Mutation.Import(childComplexity), true
	case "Mutation.task":
		if e.complexity.Mutation.Task == nil {
			break
		}

		return e.complexity.Mutation.Task(childComplexity), true

	case "OffsetPageInfo.hasNextPage":
		if e.complexity.OffsetPageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.OffsetPageInfo.HasNextPage(childComplexity), true
	case "OffsetPageInfo.hasPreviousPage":
		if e.complexity.OffsetPageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.OffsetPageInfo.HasPreviousPage(childComplexity), true
	case "OffsetPageInfo.limit":
		if e.complexity.OffsetPageInfo.Limit == nil {
			break
		}

		return e.complexity.OffsetPageInfo.Limit(childComplexity), true
	case "OffsetPageInfo.offset":
		if e.complexity.OffsetPageInfo.Offset == nil {
			break
		}

		return e.complexity.OffsetPageInfo.Offset(childComplexity), true

	case "OptionExample.help":
		if e.complexity.OptionExample.Help == nil {
			break
		}

		return e.complexity.OptionExample.Help(childComplexity), true
	case "OptionExample.value":
		if e.complexity.OptionExample.Value == nil {
			break
		}

		return e.complexity.OptionExample.Value(childComplexity), true

	case "ParsedConnection.config":
		if e.complexity.ParsedConnection.Config == nil {
			break
		}

		return e.complexity.ParsedConnection.Config(childComplexity), true
	case "ParsedConnection.name":
		if e.complexity.ParsedConnection.Name == nil {
			break
		}

		return e.complexity.ParsedConnection.Name(childComplexity), true
	case "ParsedConnection.type":
		if e.complexity.ParsedConnection.Type == nil {
			break
		}

		return e.complexity.ParsedConnection.Type(childComplexity), true

	case "Provider.description":
		if e.complexity.Provider.Description == nil {
			break
		}

		return e.complexity.Provider.Description(childComplexity), true
	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true
	case "Provider.options":
		if e.complexity.Provider.Options == nil {
			break
		}

		return e.complexity.Provider.Options(childComplexity), true
	case "Provider.prefix":
		if e.complexity.Provider.Prefix == nil {
			break
		}

		return e.complexity.Provider.Prefix(childComplexity), true

	case "ProviderOption.advanced":
		if e.complexity.ProviderOption.Advanced == nil {
			break
		}

		return e.complexity.ProviderOption.Advanced(childComplexity), true
	case "ProviderOption.default":
		if e.complexity.ProviderOption.Default == nil {
			break
		}

		return e.complexity.ProviderOption.Default(childComplexity), true
	case "ProviderOption.examples":
		if e.complexity.ProviderOption.Examples == nil {
			break
		}

		return e.complexity.ProviderOption.Examples(childComplexity), true
	case "ProviderOption.exclusive":
		if e.complexity.ProviderOption.Exclusive == nil {
			break
		}

		return e.complexity.ProviderOption.Exclusive(childComplexity), true
	case "ProviderOption.groups":
		if e.complexity.ProviderOption.Groups == nil {
			break
		}

		return e.complexity.ProviderOption.Groups(childComplexity), true
	case "ProviderOption.help":
		if e.complexity.ProviderOption.Help == nil {
			break
		}

		return e.complexity.ProviderOption.Help(childComplexity), true
	case "ProviderOption.isPassword":
		if e.complexity.ProviderOption.IsPassword == nil {
			break
		}

		return e.complexity.ProviderOption.IsPassword(childComplexity), true
	case "ProviderOption.name":
		if e.complexity.ProviderOption.Name == nil {
			break
		}

		return e.complexity.ProviderOption.Name(childComplexity), true
	case "ProviderOption.required":
		if e.complexity.ProviderOption.Required == nil {
			break
		}

		return e.complexity.ProviderOption.Required(childComplexity), true
	case "ProviderOption.type":
		if e.complexity.ProviderOption.Type == nil {
			break
		}

		return e.complexity.ProviderOption.Type(childComplexity), true

	case "ProviderQuery.get":
		if e.complexity.ProviderQuery.Get == nil {
			break
		}

		args, err := ec.field_ProviderQuery_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ProviderQuery.Get(childComplexity, args["name"].(string)), true
	case "ProviderQuery.list":
		if e.complexity.ProviderQuery.List == nil {
			break
		}

		return e.complexity.ProviderQuery.List(childComplexity), true

	case "Query.connection":
		if e.complexity.Query.Connection == nil {
			break
		}

		return e.complexity.Query.Connection(childComplexity), true
	case "Query.file":
		if e.complexity.Query.File == nil {
			break
		}

		return e.complexity.Query.File(childComplexity), true
	case "Query.job":
		if e.complexity.Query.Job == nil {
			break
		}

		return e.complexity.Query.Job(childComplexity), true
	case "Query.log":
		if e.complexity.Query.Log == nil {
			break
		}

		return e.complexity.Query.Log(childComplexity), true
	case "Query.provider":
		if e.complexity.Query.Provider == nil {
			break
		}

		return e.complexity.Query.Provider(childComplexity), true
	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		return e.complexity.Query.Task(childComplexity), true

	case "Subscription.jobProgress":
		if e.complexity.Subscription.JobProgress == nil {
			break
		}

		args, err := ec.field_Subscription_jobProgress_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.JobProgress(childComplexity, args["taskId"].(*uuid.UUID), args["connectionId"].(*uuid.UUID)), true
	case "Subscription.transferProgress":
		if e.complexity.Subscription.TransferProgress == nil {
			break
		}

		args, err := ec.field_Subscription_transferProgress_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.TransferProgress(childComplexity, args["connectionId"].(*uuid.UUID), args["taskId"].(*uuid.UUID), args["jobId"].(*uuid.UUID)), true

	case "Task.connection":
		if e.complexity.Task.Connection == nil {
			break
		}

		return e.complexity.Task.Connection(childComplexity), true
	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true
	case "Task.direction":
		if e.complexity.Task.Direction == nil {
			break
		}

		return e.complexity.Task.Direction(childComplexity), true
	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true
	case "Task.jobs":
		if e.complexity.Task.Jobs == nil {
			break
		}

		args, err := ec.field_Task_jobs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Jobs(childComplexity, args["pagination"].(*model.PaginationInput)), true
	case "Task.latestJob":
		if e.complexity.Task.LatestJob == nil {
			break
		}

		return e.complexity.Task.LatestJob(childComplexity), true
	case "Task.name":
		if e.complexity.Task.Name == nil {
			break
		}

		return e.complexity.Task.Name(childComplexity), true
	case "Task.options":
		if e.complexity.Task.Options == nil {
			break
		}

		return e.complexity.Task.Options(childComplexity), true
	case "Task.realtime":
		if e.complexity.Task.Realtime == nil {
			break
		}

		return e.complexity.Task.Realtime(childComplexity), true
	case "Task.remotePath":
		if e.complexity.Task.RemotePath == nil {
			break
		}

		return e.complexity.Task.RemotePath(childComplexity), true
	case "Task.schedule":
		if e.complexity.Task.Schedule == nil {
			break
		}

		return e.complexity.Task.Schedule(childComplexity), true
	case "Task.sourcePath":
		if e.complexity.Task.SourcePath == nil {
			break
		}

		return e.complexity.Task.SourcePath(childComplexity), true
	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "TaskConnection.items":
		if e.complexity.TaskConnection.Items == nil {
			break
		}

		return e.complexity.TaskConnection.Items(childComplexity), true
	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true
	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskMutation.create":
		if e.complexity.TaskMutation.Create == nil {
			break
		}

		args, err := ec.field_TaskMutation_create_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskMutation.Create(childComplexity, args["input"].(model.CreateTaskInput)), true
	case "TaskMutation.delete":
		if e.complexity.TaskMutation.Delete == nil {
			break
		}

		args, err := ec.field_TaskMutation_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskMutation.Delete(childComplexity, args["id"].(uuid.UUID)), true
	case "TaskMutation.run":
		if e.complexity.TaskMutation.Run == nil {
			break
		}

		args, err := ec.field_TaskMutation_run_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskMutation.Run(childComplexity, args["taskId"].(uuid.UUID)), true
	case "TaskMutation.update":
		if e.complexity.TaskMutation.Update == nil {
			break
		}

		args, err := ec.field_TaskMutation_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskMutation.Update(childComplexity, args["id"].(uuid.UUID), args["input"].(model.UpdateTaskInput)), true

	case "TaskQuery.get":
		if e.complexity.TaskQuery.Get == nil {
			break
		}

		args, err := ec.field_TaskQuery_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskQuery.Get(childComplexity, args["id"].(uuid.UUID)), true
	case "TaskQuery.list":
		if e.complexity.TaskQuery.List == nil {
			break
		}

		args, err := ec.field_TaskQuery_list_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TaskQuery.List(childComplexity, args["pagination"].(*model.PaginationInput)), true

	case "TaskSyncOptions.conflictResolution":
		if e.complexity.TaskSyncOptions.ConflictResolution == nil {
			break
		}

		return e.complexity.TaskSyncOptions.ConflictResolution(childComplexity), true

	case "TransferItem.bytes":
		if e.complexity.TransferItem.Bytes == nil {
			break
		}

		return e.complexity.TransferItem.Bytes(childComplexity), true
	case "TransferItem.name":
		if e.complexity.TransferItem.Name == nil {
			break
		}

		return e.complexity.TransferItem.Name(childComplexity), true
	case "TransferItem.size":
		if e.complexity.TransferItem.Size == nil {
			break
		}

		return e.complexity.TransferItem.Size(childComplexity), true

	case "TransferProgressEvent.connectionId":
		if e.complexity.TransferProgressEvent.ConnectionID == nil {
			break
		}

		return e.complexity.TransferProgressEvent.ConnectionID(childComplexity), true
	case "TransferProgressEvent.jobId":
		if e.complexity.TransferProgressEvent.JobID == nil {
			break
		}

		return e.complexity.TransferProgressEvent.JobID(childComplexity), true
	case "TransferProgressEvent.taskId":
		if e.complexity.TransferProgressEvent.TaskID == nil {
			break
		}

		return e.complexity.TransferProgressEvent.TaskID(childComplexity), true
	case "TransferProgressEvent.transfers":
		if e.complexity.TransferProgressEvent.Transfers == nil {
			break
		}

		return e.complexity.TransferProgressEvent.Transfers(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateConnectionInput,
		ec.unmarshalInputCreateTaskInput,
		ec.unmarshalInputImportConnectionInput,
		ec.unmarshalInputImportExecuteInput,
		ec.unmarshalInputImportParseInput,
		ec.unmarshalInputPaginationInput,
		ec.unmarshalInputTaskSyncOptionsInput,
		ec.unmarshalInputTestConnectionInput,
		ec.unmarshalInputUpdateConnectionInput,
		ec.unmarshalInputUpdateTaskInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/connection.graphql", Input: `# GraphQL Schema: Connection 相关类型定义

# =============================================================================
# ENUMS
# =============================================================================

"""
连接加载状态
"""
enum ConnectionLoadStatus {
	"""
	已加载
	"""
	LOADED
	"""
	加载中
	"""
	LOADING
	"""
	加载失败
	"""
	ERROR
}

# =============================================================================
# TYPES
# =============================================================================

"""
远程存储连接
"""
type Connection {
	"""
	UUID 主键
	"""
	id: ID!
	"""
	连接名称（系统唯一）
	"""
	name: String!
	"""
	提供者类型（如 onedrive, s3, drive）
	"""
	type: String!
	"""
	配置参数（解密后，需要解密处理）
	"""
	config: StringMap! @goField(forceResolver: true)
	"""
	加载状态（运行时状态）
	"""
	loadStatus: ConnectionLoadStatus! @goField(forceResolver: true)
	"""
	加载错误信息（运行时状态，仅当 loadStatus 为 ERROR 时有值）
	"""
	loadError: String @goField(forceResolver: true)
	"""
	创建时间
	"""
	createdAt: DateTime!
	"""
	更新时间
	"""
	updatedAt: DateTime!
	"""
	使用此连接的任务（分页查询）
	"""
	tasks(pagination: PaginationInput): TaskConnection! @goField(forceResolver: true)
	"""
	配额信息（调用 rclone about API）
	"""
	quota: ConnectionQuota @goField(forceResolver: true)
}

"""
连接配额信息
"""
type ConnectionQuota {
	"""
	总空间（字节），可能为 null 如果存储不支持
	"""
	total: BigInt
	"""
	已使用空间（字节），可能为 null 如果存储不支持
	"""
	used: BigInt
	"""
	可用空间（字节），可能为 null 如果存储不支持
	"""
	free: BigInt
	"""
	回收站占用空间（字节），可能为 null 如果存储不支持
	"""
	trashed: BigInt
	"""
	其他空间占用（字节），如版本控制、元数据等，可能为 null
	"""
	other: BigInt
	"""
	对象/文件数量，可能为 null 如果存储不支持
	"""
	objects: BigInt
}

"""
连接分页连接
"""
type ConnectionConnection {
	"""
	连接列表
	"""
	items: [Connection!]!
	"""
	总数
	"""
	totalCount: Int!
	"""
	分页信息
	"""
	pageInfo: OffsetPageInfo!
}

# =============================================================================
# INPUT TYPES
# =============================================================================

"""
创建连接输入
"""
input CreateConnectionInput {
	"""
	连接名称
	"""
	name: String!
	"""
	提供者类型
	"""
	type: String!
	"""
	配置参数
	"""
	config: StringMap!
}

"""
更新连接输入
"""
input UpdateConnectionInput {
	"""
	连接名称
	"""
	name: String
	"""
	配置参数
	"""
	config: StringMap
}

"""
测试连接输入（未保存的配置）
"""
input TestConnectionInput {
	"""
	提供者类型
	"""
	type: String!
	"""
	配置参数
	"""
	config: StringMap!
}

# =============================================================================
# RESULT TYPES
# =============================================================================

"""
连接测试成功
"""
type ConnectionTestSuccess {
	"""
	成功消息（已本地化）
	"""
	message: String!
}

"""
连接测试失败
"""
type ConnectionTestFailure {
	"""
	错误消息（已本地化）
	"""
	error: String!
}

"""
测试连接结果
"""
union TestConnectionResult = ConnectionTestSuccess | ConnectionTestFailure

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
连接查询命名空间
"""
type ConnectionQuery {
	"""
	获取连接列表
	"""
	list(pagination: PaginationInput): ConnectionConnection! @goField(forceResolver: true)
	"""
	获取单个连接
	"""
	get(id: ID!): Connection @goField(forceResolver: true)
}

"""
连接变更命名空间
"""
type ConnectionMutation {
	"""
	创建连接（失败抛出 GraphQL error）
	"""
	create(input: CreateConnectionInput!): Connection! @goField(forceResolver: true)
	"""
	更新连接（失败抛出 GraphQL error）
	"""
	update(id: ID!, input: UpdateConnectionInput!): Connection! @goField(forceResolver: true)
	"""
	删除连接（失败抛出 GraphQL error）
	"""
	delete(id: ID!): Connection! @goField(forceResolver: true)
	"""
	测试已保存的连接（测试失败是预期业务结果，用 union 表示）
	"""
	test(id: ID!): TestConnectionResult! @goField(forceResolver: true)
	"""
	测试未保存的连接配置（测试失败是预期业务结果，用 union 表示）
	"""
	testUnsaved(input: TestConnectionInput!): TestConnectionResult! @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Query {
	"""
	连接相关查询（命名空间）
	"""
	connection: ConnectionQuery! @goField(forceResolver: true)
}

extend type Mutation {
	"""
	连接相关变更（命名空间）
	"""
	connection: ConnectionMutation! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../schema/file.graphql", Input: `# GraphQL Schema: File 相关类型定义

# =============================================================================
# TYPES
# =============================================================================

"""
文件/目录条目
"""
type FileEntry {
	"""
	文件名
	"""
	name: String!
	"""
	完整路径
	"""
	path: String!
	"""
	是否为目录
	"""
	isDir: Boolean!
}

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
文件查询命名空间
"""
type FileQuery {
	"""
	列出本地目录内容
	"""
	local(
		"""
		目录路径
		"""
		path: String!
	): [FileEntry!]! @goField(forceResolver: true)
	"""
	列出远程目录内容
	"""
	remote(
		"""
		连接 ID
		"""
		connectionId: ID!
		"""
		目录路径
		"""
		path: String!
	): [FileEntry!]! @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Query {
	"""
	文件相关查询（命名空间）
	"""
	file: FileQuery! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../schema/import.graphql", Input: `# GraphQL Schema: Import 相关类型定义

# =============================================================================
# INPUT TYPES
# =============================================================================

"""
导入解析输入
"""
input ImportParseInput {
	"""
	rclone 配置文件内容
	"""
	content: String!
}

"""
导入执行输入
"""
input ImportExecuteInput {
	"""
	要导入的连接列表
	"""
	connections: [ImportConnectionInput!]!
}

"""
导入连接输入
"""
input ImportConnectionInput {
	"""
	连接名称
	"""
	name: String!
	"""
	提供者类型
	"""
	type: String!
	"""
	配置参数
	"""
	config: StringMap!
}

# =============================================================================
# RESULT TYPES
# =============================================================================

"""
解析出的连接
"""
type ParsedConnection {
	"""
	连接名称
	"""
	name: String!
	"""
	提供者类型
	"""
	type: String!
	"""
	配置参数
	"""
	config: StringMap!
}

"""
导入解析成功
"""
type ImportParseSuccess {
	"""
	解析出的连接列表
	"""
	connections: [ParsedConnection!]!
}

"""
导入解析错误
"""
type ImportParseError {
	"""
	错误消息（已本地化）
	"""
	error: String!
	"""
	错误行号
	"""
	line: Int
}

"""
导入解析结果
"""
union ImportParseResult = ImportParseSuccess | ImportParseError

"""
导入执行结果
"""
type ImportExecuteResult {
	"""
	成功导入的连接列表
	"""
	connections: [Connection!]!
	"""
	跳过的连接数（名称冲突）
	"""
	skippedCount: Int!
}

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
导入变更命名空间
"""
type ImportMutation {
	"""
	解析 rclone 配置文件（解析失败是预期业务结果，用 union 表示）
	"""
	parse(input: ImportParseInput!): ImportParseResult! @goField(forceResolver: true)
	"""
	执行导入（失败抛出 GraphQL error）
	"""
	execute(input: ImportExecuteInput!): ImportExecuteResult! @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Mutation {
	"""
	导入相关变更（命名空间）
	"""
	import: ImportMutation! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../schema/job.graphql", Input: `# GraphQL Schema: Job 相关类型定义（包含 Log 和 Subscription 事件）

# =============================================================================
# ENUMS
# =============================================================================

"""
作业执行状态
"""
enum JobStatus {
	"""
	等待执行
	"""
	PENDING
	"""
	执行中
	"""
	RUNNING
	"""
	成功完成
	"""
	SUCCESS
	"""
	执行失败
	"""
	FAILED
	"""
	已取消
	"""
	CANCELLED
}

"""
作业触发方式
"""
enum JobTrigger {
	"""
	手动触发
	"""
	MANUAL
	"""
	定时触发
	"""
	SCHEDULE
	"""
	实时触发（文件变更）
	"""
	REALTIME
}

"""
日志级别
"""
enum LogLevel {
	INFO
	WARNING
	ERROR
}

"""
日志操作类型
"""
enum LogAction {
	"""
	上传文件
	"""
	UPLOAD
	"""
	下载文件
	"""
	DOWNLOAD
	"""
	删除文件
	"""
	DELETE
	"""
	移动文件
	"""
	MOVE
	"""
	错误
	"""
	ERROR
	"""
	未知操作
	"""
	UNKNOWN
}

# =============================================================================
# TYPES
# =============================================================================

"""
作业执行记录
"""
type Job @goExtraField(name: "TaskID", type: "github.com/google/uuid.UUID") {
	"""
	UUID 主键
	"""
	id: ID!
	"""
	执行状态
	"""
	status: JobStatus!
	"""
	触发方式
	"""
	trigger: JobTrigger!
	"""
	开始时间
	"""
	startTime: DateTime!
	"""
	结束时间
	"""
	endTime: DateTime
	"""
	已传输文件数
	"""
	filesTransferred: Int!
	"""
	已传输字节数
	"""
	bytesTransferred: BigInt!
	"""
	删除的文件数
	"""
	filesDeleted: Int!
	"""
	错误数量
	"""
	errorCount: Int!
	"""
	错误信息
	"""
	errors: String
	"""
	关联的任务（ent edge）
	"""
	task: Task! @goField(forceResolver: true)
	"""
	执行日志（分页查询）
	"""
	logs(pagination: PaginationInput): JobLogConnection! @goField(forceResolver: true)
	"""
	运行时进度（仅 RUNNING 状态的 job 有值，其他状态返回 null）
	"""
	progress: JobProgressEvent @goField(forceResolver: true)
}

"""
作业日志条目
"""
type JobLog @goExtraField(name: "JobID", type: "github.com/google/uuid.UUID") {
	"""
	自增主键
	"""
	id: Int!
	"""
	日志级别
	"""
	level: LogLevel!
	"""
	日志时间
	"""
	time: DateTime!
	"""
	文件路径
	"""
	path: String!
	"""
	操作类型
	"""
	what: LogAction!
	"""
	文件大小（字节）
	"""
	size: BigInt!
	"""
	关联的作业（ent edge）
	"""
	job: Job! @goField(forceResolver: true)
}

"""
作业分页连接
"""
type JobConnection {
	"""
	作业列表
	"""
	items: [Job!]!
	"""
	总数
	"""
	totalCount: Int!
	"""
	分页信息
	"""
	pageInfo: OffsetPageInfo!
}

"""
日志分页连接
"""
type JobLogConnection {
	"""
	日志列表
	"""
	items: [JobLog!]!
	"""
	总数
	"""
	totalCount: Int!
	"""
	分页信息
	"""
	pageInfo: OffsetPageInfo!
}

# =============================================================================
# SUBSCRIPTION EVENT TYPES
# =============================================================================

"""
作业进度事件
"""
type JobProgressEvent {
	"""
	作业 ID
	"""
	jobId: ID!
	"""
	关联的任务 ID
	"""
	taskId: ID!
	"""
	关联的连接 ID
	"""
	connectionId: ID!
	"""
	当前状态
	"""
	status: JobStatus!
	"""
	已传输文件数
	"""
	filesTransferred: Int!
	"""
	已传输字节数
	"""
	bytesTransferred: BigInt!
	"""
	总文件数（队列+已完成+进行中），会随扫描动态增加
	"""
	filesTotal: Int!
	"""
	总字节数（队列大小+已传输+正在传输的总大小）
	"""
	bytesTotal: BigInt!
	"""
	删除的文件数
	"""
	filesDeleted: Int!
	"""
	错误数量
	"""
	errorCount: Int!
	"""
	开始时间
	"""
	startTime: DateTime!
	"""
	结束时间
	"""
	endTime: DateTime
}

"""
当前正在传输的文件项
"""
type TransferItem {
	"""
	文件名称（含路径），如 "documents/report.pdf"
	"""
	name: String!
	"""
	文件总大小（字节）
	"""
	size: BigInt!
	"""
	已传输字节数
	"""
	bytes: BigInt!
}

"""
传输进度事件 - 当前正在传输的文件列表
"""
type TransferProgressEvent {
	"""
	关联的作业 ID
	"""
	jobId: ID!
	"""
	关联的任务 ID
	"""
	taskId: ID!
	"""
	关联的连接 ID
	"""
	connectionId: ID!
	"""
	当前正在传输的文件列表
	"""
	transfers: [TransferItem!]!
}

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
作业查询命名空间
"""
type JobQuery {
	"""
	获取作业列表
	"""
	list(
		"""
		按任务 ID 过滤
		"""
		taskId: ID
		"""
		按连接 ID 过滤
		"""
		connectionId: ID
		"""
		分页参数
		"""
		pagination: PaginationInput
	): JobConnection! @goField(forceResolver: true)
	"""
	获取单个作业
	"""
	get(id: ID!): Job
	"""
	获取作业进度
	"""
	progress(id: ID!): JobProgressEvent @goField(forceResolver: true)
}

"""
日志查询命名空间
"""
type LogQuery {
	"""
	获取日志列表
	"""
	list(
		"""
		按连接 ID 过滤（必填）
		"""
		connectionId: ID!
		"""
		按任务 ID 过滤
		"""
		taskId: ID
		"""
		按作业 ID 过滤
		"""
		jobId: ID
		"""
		按日志级别过滤
		"""
		level: LogLevel
		"""
		分页参数
		"""
		pagination: PaginationInput
	): JobLogConnection! @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Query {
	"""
	作业相关查询（命名空间）
	"""
	job: JobQuery! @goField(forceResolver: true)
	"""
	日志相关查询（命名空间）
	"""
	log: LogQuery! @goField(forceResolver: true)
}

extend type Subscription {
	"""
	订阅作业进度事件

	- 无参数：订阅所有作业进度（全局订阅）
	- taskId：仅订阅指定任务的作业
	- connectionId：仅订阅指定连接相关的作业
	"""
	jobProgress(
		"""
		按任务 ID 过滤
		"""
		taskId: ID
		"""
		按连接 ID 过滤
		"""
		connectionId: ID
	): JobProgressEvent!

	"""
	订阅传输进度事件

	推送机制：
	- 增量推送：仅推送有变化的传输项（新增、进度更新）
	- 传输完成时推送：每个文件传输完成时推送一次（此时 bytes == size）
	- 前端应根据 name 合并/更新传输列表，当 bytes == size 时可移除该项

	"""
	transferProgress(
		"""
		按连接 ID 筛选
		"""
		connectionId: ID
		"""
		按任务 ID 筛选
		"""
		taskId: ID
		"""
		按作业 ID 筛选
		"""
		jobId: ID
	): TransferProgressEvent!
}
`, BuiltIn: false},
	{Name: "../schema/provider.graphql", Input: `# GraphQL Schema: Provider 相关类型定义

# =============================================================================
# TYPES
# =============================================================================

"""
存储提供者
"""
type Provider {
	"""
	提供者名称（如 onedrive, s3）
	"""
	name: String!
	"""
	描述
	"""
	description: String!
	"""
	前缀标识
	"""
	prefix: String!
	"""
	配置选项列表
	"""
	options: [ProviderOption!]!
}

"""
提供者配置选项
"""
type ProviderOption {
	"""
	选项名称
	"""
	name: String!
	"""
	帮助文本
	"""
	help: String!
	"""
	是否必填
	"""
	required: Boolean!
	"""
	是否密码字段
	"""
	isPassword: Boolean!
	"""
	默认值
	"""
	default: String
	"""
	示例值列表
	"""
	examples: [OptionExample!]
	"""
	是否高级选项
	"""
	advanced: Boolean!
	"""
	选项分组
	"""
	groups: String
	"""
	是否独占选择（使用下拉框而非输入框）
	"""
	exclusive: Boolean!
	"""
	选项数据类型
	"""
	type: String!
}

"""
选项示例
"""
type OptionExample {
	"""
	示例值
	"""
	value: String!
	"""
	帮助说明
	"""
	help: String
}

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
提供者查询命名空间
"""
type ProviderQuery {
	"""
	获取所有存储提供者
	"""
	list: [Provider!]! @goField(forceResolver: true)
	"""
	获取单个提供者的配置选项
	"""
	get(name: String!): Provider @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Query {
	"""
	提供者相关查询（命名空间）
	"""
	provider: ProviderQuery! @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../schema/schema.graphql", Input: `# GraphQL Schema: Rclone Cloud Sync Manager
# Feature Branch: 007-graphql-migration
# Date: 2025-12-20

# Schema 设计采用命名空间模式，按实体拆分 Query 和 Mutation
# 各模块使用 extend 来扩展根类型

# =============================================================================
# DIRECTIVES (gqlgen built-in)
# =============================================================================

directive @goField(
	forceResolver: Boolean
	name: String
	omittable: Boolean
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goModel(
	model: String
	models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goEnum(
	value: String
) on ENUM_VALUE

directive @goTag(
	key: String!
	value: String!
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goExtraField(
	name: String!
	type: String!
	overrideTags: String
	description: String
) repeatable on OBJECT | INPUT_OBJECT

# =============================================================================
# SCALARS
# =============================================================================

"""
ISO 8601 日期时间格式
"""
scalar DateTime

"""
任意 JSON 对象
"""
scalar JSON

"""
64位整数（用于字节数等大数值）
"""
scalar BigInt

"""
字符串键值对（map[string]string）
用于 rclone 配置参数，所有值必须为字符串
"""
scalar StringMap

# =============================================================================
# PAGINATION TYPES
# =============================================================================

"""
分页输入
"""
input PaginationInput {
	"""
	每页数量（默认 20）
	"""
	limit: Int = 20
	"""
	偏移量（默认 0）
	"""
	offset: Int = 0
}

"""
偏移量分页信息
"""
type OffsetPageInfo {
	"""
	当前页大小
	"""
	limit: Int!
	"""
	当前偏移量
	"""
	offset: Int!
	"""
	是否有下一页
	"""
	hasNextPage: Boolean!
	"""
	是否有上一页
	"""
	hasPreviousPage: Boolean!
}

# =============================================================================
# ROOT TYPES (空实现，由各模块 extend 扩展)
# =============================================================================

type Query

type Mutation

type Subscription

schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}
`, BuiltIn: false},
	{Name: "../schema/task.graphql", Input: `# GraphQL Schema: Task 相关类型定义

# =============================================================================
# ENUMS
# =============================================================================

"""
同步方向
"""
enum SyncDirection {
	"""
	本地上传到远程
	"""
	UPLOAD
	"""
	远程下载到本地
	"""
	DOWNLOAD
	"""
	双向同步
	"""
	BIDIRECTIONAL
}

"""
冲突解决策略（仅用于双向同步）
"""
enum ConflictResolution {
	"""
	保留较新文件，重命名较旧文件
	"""
	NEWER
	"""
	保留本地文件，删除远程
	"""
	LOCAL
	"""
	保留远程文件，删除本地
	"""
	REMOTE
	"""
	保留两者，添加冲突后缀
	"""
	BOTH
}

# =============================================================================
# TYPES
# =============================================================================

"""
任务同步选项
"""
type TaskSyncOptions {
	"""
	冲突解决策略（默认 NEWER，仅用于双向同步）
	"""
	conflictResolution: ConflictResolution
}

"""
同步任务
"""
type Task @goExtraField(name: "ConnectionID", type: "github.com/google/uuid.UUID") {
	"""
	UUID 主键
	"""
	id: ID!
	"""
	任务名称
	"""
	name: String!
	"""
	本地源路径
	"""
	sourcePath: String!
	"""
	远程目标路径
	"""
	remotePath: String!
	"""
	同步方向
	"""
	direction: SyncDirection!
	"""
	Cron 调度表达式
	"""
	schedule: String
	"""
	是否启用实时同步
	"""
	realtime: Boolean!
	"""
	同步选项（JSON → 类型转换）
	"""
	options: TaskSyncOptions @goField(forceResolver: true)
	"""
	创建时间
	"""
	createdAt: DateTime!
	"""
	更新时间
	"""
	updatedAt: DateTime!
	"""
	关联的远程连接（ent edge）
	"""
	connection: Connection! @goField(forceResolver: true)
	"""
	作业历史（分页查询）
	"""
	jobs(pagination: PaginationInput): JobConnection! @goField(forceResolver: true)
	"""
	最近一次作业（计算字段）
	"""
	latestJob: Job @goField(forceResolver: true)
}

"""
任务分页连接
"""
type TaskConnection {
	"""
	任务列表
	"""
	items: [Task!]!
	"""
	总数
	"""
	totalCount: Int!
	"""
	分页信息
	"""
	pageInfo: OffsetPageInfo!
}

# =============================================================================
# INPUT TYPES
# =============================================================================

"""
任务同步选项输入
"""
input TaskSyncOptionsInput {
	"""
	冲突解决策略（默认 NEWER，仅用于双向同步）
	"""
	conflictResolution: ConflictResolution
}

"""
创建任务输入
"""
input CreateTaskInput {
	"""
	任务名称
	"""
	name: String!
	"""
	本地源路径
	"""
	sourcePath: String!
	"""
	关联连接 ID
	"""
	connectionId: ID!
	"""
	远程目标路径
	"""
	remotePath: String!
	"""
	同步方向
	"""
	direction: SyncDirection!
	"""
	Cron 调度表达式
	"""
	schedule: String
	"""
	是否启用实时同步
	"""
	realtime: Boolean = false
	"""
	同步选项
	"""
	options: TaskSyncOptionsInput
}

"""
更新任务输入
"""
input UpdateTaskInput {
	"""
	任务名称
	"""
	name: String
	"""
	本地源路径
	"""
	sourcePath: String
	"""
	关联连接 ID
	"""
	connectionId: ID
	"""
	远程目标路径
	"""
	remotePath: String
	"""
	同步方向
	"""
	direction: SyncDirection
	"""
	Cron 调度表达式
	"""
	schedule: String
	"""
	是否启用实时同步
	"""
	realtime: Boolean
	"""
	同步选项
	"""
	options: TaskSyncOptionsInput
}

# =============================================================================
# NAMESPACED TYPES
# =============================================================================

"""
任务查询命名空间
"""
type TaskQuery {
	"""
	获取任务列表
	"""
	list(pagination: PaginationInput): TaskConnection! @goField(forceResolver: true)
	"""
	获取单个任务
	"""
	get(id: ID!): Task @goField(forceResolver: true)
}

"""
任务变更命名空间
"""
type TaskMutation {
	"""
	创建任务（失败抛出 GraphQL error）
	"""
	create(input: CreateTaskInput!): Task! @goField(forceResolver: true)
	"""
	更新任务（失败抛出 GraphQL error）
	"""
	update(id: ID!, input: UpdateTaskInput!): Task! @goField(forceResolver: true)
	"""
	删除任务（失败抛出 GraphQL error）
	"""
	delete(id: ID!): Task! @goField(forceResolver: true)
	"""
	运行任务（创建并启动作业，失败抛出 GraphQL error）
	"""
	run(taskId: ID!): Job! @goField(forceResolver: true)
}

# =============================================================================
# EXTEND ROOT TYPES
# =============================================================================

extend type Query {
	"""
	任务相关查询（命名空间）
	"""
	task: TaskQuery! @goField(forceResolver: true)
}

extend type Mutation {
	"""
	任务相关变更（命名空间）
	"""
	task: TaskMutation! @goField(forceResolver: true)
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_ConnectionMutation_create_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐCreateConnectionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConnectionMutation_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConnectionMutation_testUnsaved_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNTestConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTestConnectionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConnectionMutation_test_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConnectionMutation_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐUpdateConnectionInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_ConnectionQuery_get_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_ConnectionQuery_list_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_Connection_tasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_FileQuery_local_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "path", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["path"] = arg0
	return args, nil
}

func (ec *executionContext) field_FileQuery_remote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "connectionId", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["connectionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "path", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["path"] = arg1
	return args, nil
}

func (ec *executionContext) field_ImportMutation_execute_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNImportExecuteInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportExecuteInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_ImportMutation_parse_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNImportParseInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportParseInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_JobQuery_get_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_JobQuery_list_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "connectionId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["connectionId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg2
	return args, nil
}

func (ec *executionContext) field_JobQuery_progress_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Job_logs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_LogQuery_list_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "connectionId", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["connectionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "jobId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["jobId"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "level", ec.unmarshalOLogLevel2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel)
	if err != nil {
		return nil, err
	}
	args["level"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg4
	return args, nil
}

func (ec *executionContext) field_ProviderQuery_get_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_jobProgress_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "connectionId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["connectionId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Subscription_transferProgress_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "connectionId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["connectionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "jobId", ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["jobId"] = arg2
	return args, nil
}

func (ec *executionContext) field_TaskMutation_create_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNCreateTaskInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐCreateTaskInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_TaskMutation_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_TaskMutation_run_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_TaskMutation_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "input", ec.unmarshalNUpdateTaskInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐUpdateTaskInput)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_TaskQuery_get_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_TaskQuery_list_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field_Task_jobs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "pagination", ec.unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Connection_id(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_name(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_type(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_config(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_config,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Connection().Config(ctx, obj)
		},
		nil,
		ec.marshalNStringMap2map,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_config(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_loadStatus(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_loadStatus,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Connection().LoadStatus(ctx, obj)
		},
		nil,
		ec.marshalNConnectionLoadStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionLoadStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_loadStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConnectionLoadStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_loadError(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_loadError,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Connection().LoadError(ctx, obj)
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Connection_loadError(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Connection_tasks(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_tasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Connection().Tasks(ctx, obj, fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNTaskConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Connection_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_TaskConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_TaskConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TaskConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Connection_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Connection_quota(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Connection_quota,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Connection().Quota(ctx, obj)
		},
		nil,
		ec.marshalOConnectionQuota2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionQuota,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Connection_quota(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_ConnectionQuota_total(ctx, field)
			case "used":
				return ec.fieldContext_ConnectionQuota_used(ctx, field)
			case "free":
				return ec.fieldContext_ConnectionQuota_free(ctx, field)
			case "trashed":
				return ec.fieldContext_ConnectionQuota_trashed(ctx, field)
			case "other":
				return ec.fieldContext_ConnectionQuota_other(ctx, field)
			case "objects":
				return ec.fieldContext_ConnectionQuota_objects(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionQuota", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionConnection_items(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionConnection_items,
		func(ctx context.Context) (any, error) {
			return obj.Items, nil
		},
		nil,
		ec.marshalNConnection2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionConnection_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNOffsetPageInfo2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOffsetPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limit":
				return ec.fieldContext_OffsetPageInfo_limit(ctx, field)
			case "offset":
				return ec.fieldContext_OffsetPageInfo_offset(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_OffsetPageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_OffsetPageInfo_hasPreviousPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OffsetPageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionMutation_create,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionMutation().Create(ctx, obj, fc.Args["input"].(model.CreateConnectionInput))
		},
		nil,
		ec.marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionMutation_update,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionMutation().Update(ctx, obj, fc.Args["id"].(uuid.UUID), fc.Args["input"].(model.UpdateConnectionInput))
		},
		nil,
		ec.marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionMutation_delete(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionMutation_delete,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionMutation().Delete(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionMutation_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionMutation_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionMutation_test(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionMutation_test,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionMutation().Test(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNTestConnectionResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTestConnectionResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionMutation_test(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TestConnectionResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionMutation_test_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionMutation_testUnsaved(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionMutation_testUnsaved,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionMutation().TestUnsaved(ctx, obj, fc.Args["input"].(model.TestConnectionInput))
		},
		nil,
		ec.marshalNTestConnectionResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTestConnectionResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionMutation_testUnsaved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TestConnectionResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionMutation_testUnsaved_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuery_list(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuery_list,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionQuery().List(ctx, obj, fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNConnectionConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuery_list(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_ConnectionConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_ConnectionConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ConnectionConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionQuery_list_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuery_get(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuery_get,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ConnectionQuery().Get(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuery_get(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ConnectionQuery_get_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_total(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_total,
		func(ctx context.Context) (any, error) {
			return obj.Total, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_used(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_used,
		func(ctx context.Context) (any, error) {
			return obj.Used, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_free(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_free,
		func(ctx context.Context) (any, error) {
			return obj.Free, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_free(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_trashed(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_trashed,
		func(ctx context.Context) (any, error) {
			return obj.Trashed, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_trashed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_other(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_other,
		func(ctx context.Context) (any, error) {
			return obj.Other, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_other(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionQuota_objects(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionQuota) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionQuota_objects,
		func(ctx context.Context) (any, error) {
			return obj.Objects, nil
		},
		nil,
		ec.marshalOBigInt2ᚖint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ConnectionQuota_objects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionQuota",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestFailure_error(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestFailure) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionTestFailure_error,
		func(ctx context.Context) (any, error) {
			return obj.Error, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionTestFailure_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestFailure",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectionTestSuccess_message(ctx context.Context, field graphql.CollectedField, obj *model.ConnectionTestSuccess) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConnectionTestSuccess_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConnectionTestSuccess_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectionTestSuccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileEntry_name(ctx context.Context, field graphql.CollectedField, obj *model.FileEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileEntry_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileEntry_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileEntry_path(ctx context.Context, field graphql.CollectedField, obj *model.FileEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileEntry_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileEntry_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileEntry_isDir(ctx context.Context, field graphql.CollectedField, obj *model.FileEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileEntry_isDir,
		func(ctx context.Context) (any, error) {
			return obj.IsDir, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileEntry_isDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileQuery_local(ctx context.Context, field graphql.CollectedField, obj *model.FileQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileQuery_local,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.FileQuery().Local(ctx, obj, fc.Args["path"].(string))
		},
		nil,
		ec.marshalNFileEntry2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileEntryᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileQuery_local(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FileEntry_name(ctx, field)
			case "path":
				return ec.fieldContext_FileEntry_path(ctx, field)
			case "isDir":
				return ec.fieldContext_FileEntry_isDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileEntry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FileQuery_local_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FileQuery_remote(ctx context.Context, field graphql.CollectedField, obj *model.FileQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileQuery_remote,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.FileQuery().Remote(ctx, obj, fc.Args["connectionId"].(uuid.UUID), fc.Args["path"].(string))
		},
		nil,
		ec.marshalNFileEntry2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileEntryᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileQuery_remote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FileEntry_name(ctx, field)
			case "path":
				return ec.fieldContext_FileEntry_path(ctx, field)
			case "isDir":
				return ec.fieldContext_FileEntry_isDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileEntry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FileQuery_remote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImportExecuteResult_connections(ctx context.Context, field graphql.CollectedField, obj *model.ImportExecuteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportExecuteResult_connections,
		func(ctx context.Context) (any, error) {
			return obj.Connections, nil
		},
		nil,
		ec.marshalNConnection2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportExecuteResult_connections(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportExecuteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportExecuteResult_skippedCount(ctx context.Context, field graphql.CollectedField, obj *model.ImportExecuteResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportExecuteResult_skippedCount,
		func(ctx context.Context) (any, error) {
			return obj.SkippedCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportExecuteResult_skippedCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportExecuteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportMutation_parse(ctx context.Context, field graphql.CollectedField, obj *model.ImportMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportMutation_parse,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ImportMutation().Parse(ctx, obj, fc.Args["input"].(model.ImportParseInput))
		},
		nil,
		ec.marshalNImportParseResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportParseResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportMutation_parse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImportParseResult does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImportMutation_parse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImportMutation_execute(ctx context.Context, field graphql.CollectedField, obj *model.ImportMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportMutation_execute,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ImportMutation().Execute(ctx, obj, fc.Args["input"].(model.ImportExecuteInput))
		},
		nil,
		ec.marshalNImportExecuteResult2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportExecuteResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportMutation_execute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "connections":
				return ec.fieldContext_ImportExecuteResult_connections(ctx, field)
			case "skippedCount":
				return ec.fieldContext_ImportExecuteResult_skippedCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImportExecuteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ImportMutation_execute_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImportParseError_error(ctx context.Context, field graphql.CollectedField, obj *model.ImportParseError) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportParseError_error,
		func(ctx context.Context) (any, error) {
			return obj.Error, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportParseError_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportParseError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportParseError_line(ctx context.Context, field graphql.CollectedField, obj *model.ImportParseError) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportParseError_line,
		func(ctx context.Context) (any, error) {
			return obj.Line, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImportParseError_line(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportParseError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImportParseSuccess_connections(ctx context.Context, field graphql.CollectedField, obj *model.ImportParseSuccess) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImportParseSuccess_connections,
		func(ctx context.Context) (any, error) {
			return obj.Connections, nil
		},
		nil,
		ec.marshalNParsedConnection2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐParsedConnectionᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImportParseSuccess_connections(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImportParseSuccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ParsedConnection_name(ctx, field)
			case "type":
				return ec.fieldContext_ParsedConnection_type(ctx, field)
			case "config":
				return ec.fieldContext_ParsedConnection_config(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsedConnection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_id(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_status(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNJobStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_trigger(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_trigger,
		func(ctx context.Context) (any, error) {
			return obj.Trigger, nil
		},
		nil,
		ec.marshalNJobTrigger2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobTrigger,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_trigger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobTrigger does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_startTime(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_startTime,
		func(ctx context.Context) (any, error) {
			return obj.StartTime, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_endTime(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_endTime,
		func(ctx context.Context) (any, error) {
			return obj.EndTime, nil
		},
		nil,
		ec.marshalODateTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Job_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_filesTransferred(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_filesTransferred,
		func(ctx context.Context) (any, error) {
			return obj.FilesTransferred, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_filesTransferred(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_bytesTransferred(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_bytesTransferred,
		func(ctx context.Context) (any, error) {
			return obj.BytesTransferred, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_bytesTransferred(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_filesDeleted(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_filesDeleted,
		func(ctx context.Context) (any, error) {
			return obj.FilesDeleted, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_filesDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_errorCount(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_errorCount,
		func(ctx context.Context) (any, error) {
			return obj.ErrorCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_errorCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_errors(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_errors,
		func(ctx context.Context) (any, error) {
			return obj.Errors, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Job_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_task(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Job().Task(ctx, obj)
		},
		nil,
		ec.marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Job_logs(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_logs,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Job().Logs(ctx, obj, fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNJobLogConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Job_logs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_JobLogConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_JobLogConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_JobLogConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobLogConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Job_logs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Job_progress(ctx context.Context, field graphql.CollectedField, obj *model.Job) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Job_progress,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Job().Progress(ctx, obj)
		},
		nil,
		ec.marshalOJobProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Job_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Job",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_JobProgressEvent_jobId(ctx, field)
			case "taskId":
				return ec.fieldContext_JobProgressEvent_taskId(ctx, field)
			case "connectionId":
				return ec.fieldContext_JobProgressEvent_connectionId(ctx, field)
			case "status":
				return ec.fieldContext_JobProgressEvent_status(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_JobProgressEvent_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_JobProgressEvent_bytesTransferred(ctx, field)
			case "filesTotal":
				return ec.fieldContext_JobProgressEvent_filesTotal(ctx, field)
			case "bytesTotal":
				return ec.fieldContext_JobProgressEvent_bytesTotal(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_JobProgressEvent_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_JobProgressEvent_errorCount(ctx, field)
			case "startTime":
				return ec.fieldContext_JobProgressEvent_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_JobProgressEvent_endTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobProgressEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_items(ctx context.Context, field graphql.CollectedField, obj *model.JobConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobConnection_items,
		func(ctx context.Context) (any, error) {
			return obj.Items, nil
		},
		nil,
		ec.marshalNJob2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobConnection_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "trigger":
				return ec.fieldContext_Job_trigger(ctx, field)
			case "startTime":
				return ec.fieldContext_Job_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Job_endTime(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_Job_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_Job_bytesTransferred(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_Job_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_Job_errorCount(ctx, field)
			case "errors":
				return ec.fieldContext_Job_errors(ctx, field)
			case "task":
				return ec.fieldContext_Job_task(ctx, field)
			case "logs":
				return ec.fieldContext_Job_logs(ctx, field)
			case "progress":
				return ec.fieldContext_Job_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.JobConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.JobConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNOffsetPageInfo2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOffsetPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limit":
				return ec.fieldContext_OffsetPageInfo_limit(ctx, field)
			case "offset":
				return ec.fieldContext_OffsetPageInfo_offset(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_OffsetPageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_OffsetPageInfo_hasPreviousPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OffsetPageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_id(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_level(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_level,
		func(ctx context.Context) (any, error) {
			return obj.Level, nil
		},
		nil,
		ec.marshalNLogLevel2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LogLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_time(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_time,
		func(ctx context.Context) (any, error) {
			return obj.Time, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_path(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_what(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_what,
		func(ctx context.Context) (any, error) {
			return obj.What, nil
		},
		nil,
		ec.marshalNLogAction2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogAction,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_what(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LogAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_size(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_size,
		func(ctx context.Context) (any, error) {
			return obj.Size, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLog_job(ctx context.Context, field graphql.CollectedField, obj *model.JobLog) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLog_job,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.JobLog().Job(ctx, obj)
		},
		nil,
		ec.marshalNJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLog_job(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLog",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "trigger":
				return ec.fieldContext_Job_trigger(ctx, field)
			case "startTime":
				return ec.fieldContext_Job_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Job_endTime(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_Job_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_Job_bytesTransferred(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_Job_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_Job_errorCount(ctx, field)
			case "errors":
				return ec.fieldContext_Job_errors(ctx, field)
			case "task":
				return ec.fieldContext_Job_task(ctx, field)
			case "logs":
				return ec.fieldContext_Job_logs(ctx, field)
			case "progress":
				return ec.fieldContext_Job_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLogConnection_items(ctx context.Context, field graphql.CollectedField, obj *model.JobLogConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLogConnection_items,
		func(ctx context.Context) (any, error) {
			return obj.Items, nil
		},
		nil,
		ec.marshalNJobLog2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLogConnection_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JobLog_id(ctx, field)
			case "level":
				return ec.fieldContext_JobLog_level(ctx, field)
			case "time":
				return ec.fieldContext_JobLog_time(ctx, field)
			case "path":
				return ec.fieldContext_JobLog_path(ctx, field)
			case "what":
				return ec.fieldContext_JobLog_what(ctx, field)
			case "size":
				return ec.fieldContext_JobLog_size(ctx, field)
			case "job":
				return ec.fieldContext_JobLog_job(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLogConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.JobLogConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLogConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLogConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobLogConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.JobLogConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobLogConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNOffsetPageInfo2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOffsetPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobLogConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobLogConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limit":
				return ec.fieldContext_OffsetPageInfo_limit(ctx, field)
			case "offset":
				return ec.fieldContext_OffsetPageInfo_offset(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_OffsetPageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_OffsetPageInfo_hasPreviousPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OffsetPageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_jobId(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_jobId,
		func(ctx context.Context) (any, error) {
			return obj.JobID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_jobId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_taskId(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_connectionId(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_connectionId,
		func(ctx context.Context) (any, error) {
			return obj.ConnectionID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_connectionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_status(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNJobStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JobStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_filesTransferred(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_filesTransferred,
		func(ctx context.Context) (any, error) {
			return obj.FilesTransferred, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_filesTransferred(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_bytesTransferred(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_bytesTransferred,
		func(ctx context.Context) (any, error) {
			return obj.BytesTransferred, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_bytesTransferred(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_filesTotal(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_filesTotal,
		func(ctx context.Context) (any, error) {
			return obj.FilesTotal, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_filesTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_bytesTotal(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_bytesTotal,
		func(ctx context.Context) (any, error) {
			return obj.BytesTotal, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_bytesTotal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_filesDeleted(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_filesDeleted,
		func(ctx context.Context) (any, error) {
			return obj.FilesDeleted, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_filesDeleted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_errorCount(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_errorCount,
		func(ctx context.Context) (any, error) {
			return obj.ErrorCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_errorCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_startTime(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_startTime,
		func(ctx context.Context) (any, error) {
			return obj.StartTime, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobProgressEvent_endTime(ctx context.Context, field graphql.CollectedField, obj *model.JobProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobProgressEvent_endTime,
		func(ctx context.Context) (any, error) {
			return obj.EndTime, nil
		},
		nil,
		ec.marshalODateTime2ᚖtimeᚐTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JobProgressEvent_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JobQuery_list(ctx context.Context, field graphql.CollectedField, obj *model.JobQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobQuery_list,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.JobQuery().List(ctx, obj, fc.Args["taskId"].(*uuid.UUID), fc.Args["connectionId"].(*uuid.UUID), fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNJobConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JobQuery_list(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_JobConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_JobConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_JobConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_JobQuery_list_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _JobQuery_get(ctx context.Context, field graphql.CollectedField, obj *model.JobQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobQuery_get,
		func(ctx context.Context) (any, error) {
			return obj.Get, nil
		},
		nil,
		ec.marshalOJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JobQuery_get(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobQuery",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "trigger":
				return ec.fieldContext_Job_trigger(ctx, field)
			case "startTime":
				return ec.fieldContext_Job_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Job_endTime(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_Job_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_Job_bytesTransferred(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_Job_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_Job_errorCount(ctx, field)
			case "errors":
				return ec.fieldContext_Job_errors(ctx, field)
			case "task":
				return ec.fieldContext_Job_task(ctx, field)
			case "logs":
				return ec.fieldContext_Job_logs(ctx, field)
			case "progress":
				return ec.fieldContext_Job_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_JobQuery_get_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _JobQuery_progress(ctx context.Context, field graphql.CollectedField, obj *model.JobQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JobQuery_progress,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.JobQuery().Progress(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOJobProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JobQuery_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JobQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_JobProgressEvent_jobId(ctx, field)
			case "taskId":
				return ec.fieldContext_JobProgressEvent_taskId(ctx, field)
			case "connectionId":
				return ec.fieldContext_JobProgressEvent_connectionId(ctx, field)
			case "status":
				return ec.fieldContext_JobProgressEvent_status(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_JobProgressEvent_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_JobProgressEvent_bytesTransferred(ctx, field)
			case "filesTotal":
				return ec.fieldContext_JobProgressEvent_filesTotal(ctx, field)
			case "bytesTotal":
				return ec.fieldContext_JobProgressEvent_bytesTotal(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_JobProgressEvent_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_JobProgressEvent_errorCount(ctx, field)
			case "startTime":
				return ec.fieldContext_JobProgressEvent_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_JobProgressEvent_endTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_JobQuery_progress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LogQuery_list(ctx context.Context, field graphql.CollectedField, obj *model.LogQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogQuery_list,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.LogQuery().List(ctx, obj, fc.Args["connectionId"].(uuid.UUID), fc.Args["taskId"].(*uuid.UUID), fc.Args["jobId"].(*uuid.UUID), fc.Args["level"].(*model.LogLevel), fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNJobLogConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogQuery_list(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_JobLogConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_JobLogConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_JobLogConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobLogConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LogQuery_list_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_connection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_connection,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().Connection(ctx)
		},
		nil,
		ec.marshalNConnectionMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionMutation,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_connection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_ConnectionMutation_create(ctx, field)
			case "update":
				return ec.fieldContext_ConnectionMutation_update(ctx, field)
			case "delete":
				return ec.fieldContext_ConnectionMutation_delete(ctx, field)
			case "test":
				return ec.fieldContext_ConnectionMutation_test(ctx, field)
			case "testUnsaved":
				return ec.fieldContext_ConnectionMutation_testUnsaved(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_import(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_import,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().Import(ctx)
		},
		nil,
		ec.marshalNImportMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportMutation,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_import(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "parse":
				return ec.fieldContext_ImportMutation_parse(ctx, field)
			case "execute":
				return ec.fieldContext_ImportMutation_execute(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImportMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().Task(ctx)
		},
		nil,
		ec.marshalNTaskMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskMutation,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "create":
				return ec.fieldContext_TaskMutation_create(ctx, field)
			case "update":
				return ec.fieldContext_TaskMutation_update(ctx, field)
			case "delete":
				return ec.fieldContext_TaskMutation_delete(ctx, field)
			case "run":
				return ec.fieldContext_TaskMutation_run(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskMutation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OffsetPageInfo_limit(ctx context.Context, field graphql.CollectedField, obj *model.OffsetPageInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OffsetPageInfo_limit,
		func(ctx context.Context) (any, error) {
			return obj.Limit, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OffsetPageInfo_limit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OffsetPageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OffsetPageInfo_offset(ctx context.Context, field graphql.CollectedField, obj *model.OffsetPageInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OffsetPageInfo_offset,
		func(ctx context.Context) (any, error) {
			return obj.Offset, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OffsetPageInfo_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OffsetPageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OffsetPageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.OffsetPageInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OffsetPageInfo_hasNextPage,
		func(ctx context.Context) (any, error) {
			return obj.HasNextPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OffsetPageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OffsetPageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OffsetPageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *model.OffsetPageInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OffsetPageInfo_hasPreviousPage,
		func(ctx context.Context) (any, error) {
			return obj.HasPreviousPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OffsetPageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OffsetPageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OptionExample_value(ctx context.Context, field graphql.CollectedField, obj *model.OptionExample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OptionExample_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OptionExample_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OptionExample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OptionExample_help(ctx context.Context, field graphql.CollectedField, obj *model.OptionExample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OptionExample_help,
		func(ctx context.Context) (any, error) {
			return obj.Help, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OptionExample_help(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OptionExample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsedConnection_name(ctx context.Context, field graphql.CollectedField, obj *model.ParsedConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsedConnection_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsedConnection_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsedConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsedConnection_type(ctx context.Context, field graphql.CollectedField, obj *model.ParsedConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsedConnection_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsedConnection_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsedConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsedConnection_config(ctx context.Context, field graphql.CollectedField, obj *model.ParsedConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsedConnection_config,
		func(ctx context.Context) (any, error) {
			return obj.Config, nil
		},
		nil,
		ec.marshalNStringMap2map,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsedConnection_config(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsedConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_name(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Provider_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Provider_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_description(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Provider_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Provider_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_prefix(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Provider_prefix,
		func(ctx context.Context) (any, error) {
			return obj.Prefix, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Provider_prefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Provider_options(ctx context.Context, field graphql.CollectedField, obj *model.Provider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Provider_options,
		func(ctx context.Context) (any, error) {
			return obj.Options, nil
		},
		nil,
		ec.marshalNProviderOption2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderOptionᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Provider_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Provider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ProviderOption_name(ctx, field)
			case "help":
				return ec.fieldContext_ProviderOption_help(ctx, field)
			case "required":
				return ec.fieldContext_ProviderOption_required(ctx, field)
			case "isPassword":
				return ec.fieldContext_ProviderOption_isPassword(ctx, field)
			case "default":
				return ec.fieldContext_ProviderOption_default(ctx, field)
			case "examples":
				return ec.fieldContext_ProviderOption_examples(ctx, field)
			case "advanced":
				return ec.fieldContext_ProviderOption_advanced(ctx, field)
			case "groups":
				return ec.fieldContext_ProviderOption_groups(ctx, field)
			case "exclusive":
				return ec.fieldContext_ProviderOption_exclusive(ctx, field)
			case "type":
				return ec.fieldContext_ProviderOption_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderOption", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_name(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_help(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_help,
		func(ctx context.Context) (any, error) {
			return obj.Help, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_help(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_required(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_required,
		func(ctx context.Context) (any, error) {
			return obj.Required, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_required(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_isPassword(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_isPassword,
		func(ctx context.Context) (any, error) {
			return obj.IsPassword, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_isPassword(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_default(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_default,
		func(ctx context.Context) (any, error) {
			return obj.Default, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_default(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_examples(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_examples,
		func(ctx context.Context) (any, error) {
			return obj.Examples, nil
		},
		nil,
		ec.marshalOOptionExample2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOptionExampleᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_examples(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_OptionExample_value(ctx, field)
			case "help":
				return ec.fieldContext_OptionExample_help(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OptionExample", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_advanced(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_advanced,
		func(ctx context.Context) (any, error) {
			return obj.Advanced, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_advanced(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_groups(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_groups,
		func(ctx context.Context) (any, error) {
			return obj.Groups, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_groups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_exclusive(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_exclusive,
		func(ctx context.Context) (any, error) {
			return obj.Exclusive, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_exclusive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderOption_type(ctx context.Context, field graphql.CollectedField, obj *model.ProviderOption) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderOption_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderOption_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderOption",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderQuery_list(ctx context.Context, field graphql.CollectedField, obj *model.ProviderQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderQuery_list,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProviderQuery().List(ctx, obj)
		},
		nil,
		ec.marshalNProvider2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProviderQuery_list(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Provider_name(ctx, field)
			case "description":
				return ec.fieldContext_Provider_description(ctx, field)
			case "prefix":
				return ec.fieldContext_Provider_prefix(ctx, field)
			case "options":
				return ec.fieldContext_Provider_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Provider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProviderQuery_get(ctx context.Context, field graphql.CollectedField, obj *model.ProviderQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProviderQuery_get,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.ProviderQuery().Get(ctx, obj, fc.Args["name"].(string))
		},
		nil,
		ec.marshalOProvider2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProvider,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProviderQuery_get(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProviderQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Provider_name(ctx, field)
			case "description":
				return ec.fieldContext_Provider_description(ctx, field)
			case "prefix":
				return ec.fieldContext_Provider_prefix(ctx, field)
			case "options":
				return ec.fieldContext_Provider_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Provider", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ProviderQuery_get_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_connection,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Connection(ctx)
		},
		nil,
		ec.marshalNConnectionQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_connection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "list":
				return ec.fieldContext_ConnectionQuery_list(ctx, field)
			case "get":
				return ec.fieldContext_ConnectionQuery_get(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectionQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_file(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_file,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().File(ctx)
		},
		nil,
		ec.marshalNFileQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "local":
				return ec.fieldContext_FileQuery_local(ctx, field)
			case "remote":
				return ec.fieldContext_FileQuery_remote(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_job(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_job,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Job(ctx)
		},
		nil,
		ec.marshalNJobQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_job(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "list":
				return ec.fieldContext_JobQuery_list(ctx, field)
			case "get":
				return ec.fieldContext_JobQuery_get(ctx, field)
			case "progress":
				return ec.fieldContext_JobQuery_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_log(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_log,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Log(ctx)
		},
		nil,
		ec.marshalNLogQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_log(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "list":
				return ec.fieldContext_LogQuery_list(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_provider(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_provider,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Provider(ctx)
		},
		nil,
		ec.marshalNProviderQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "list":
				return ec.fieldContext_ProviderQuery_list(ctx, field)
			case "get":
				return ec.fieldContext_ProviderQuery_get(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProviderQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Task(ctx)
		},
		nil,
		ec.marshalNTaskQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskQuery,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "list":
				return ec.fieldContext_TaskQuery_list(ctx, field)
			case "get":
				return ec.fieldContext_TaskQuery_get(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQuery", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_jobProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_jobProgress,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().JobProgress(ctx, fc.Args["taskId"].(*uuid.UUID), fc.Args["connectionId"].(*uuid.UUID))
		},
		nil,
		ec.marshalNJobProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_jobProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_JobProgressEvent_jobId(ctx, field)
			case "taskId":
				return ec.fieldContext_JobProgressEvent_taskId(ctx, field)
			case "connectionId":
				return ec.fieldContext_JobProgressEvent_connectionId(ctx, field)
			case "status":
				return ec.fieldContext_JobProgressEvent_status(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_JobProgressEvent_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_JobProgressEvent_bytesTransferred(ctx, field)
			case "filesTotal":
				return ec.fieldContext_JobProgressEvent_filesTotal(ctx, field)
			case "bytesTotal":
				return ec.fieldContext_JobProgressEvent_bytesTotal(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_JobProgressEvent_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_JobProgressEvent_errorCount(ctx, field)
			case "startTime":
				return ec.fieldContext_JobProgressEvent_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_JobProgressEvent_endTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_jobProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_transferProgress(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	return graphql.ResolveFieldStream(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscription_transferProgress,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Subscription().TransferProgress(ctx, fc.Args["connectionId"].(*uuid.UUID), fc.Args["taskId"].(*uuid.UUID), fc.Args["jobId"].(*uuid.UUID))
		},
		nil,
		ec.marshalNTransferProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferProgressEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subscription_transferProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobId":
				return ec.fieldContext_TransferProgressEvent_jobId(ctx, field)
			case "taskId":
				return ec.fieldContext_TransferProgressEvent_taskId(ctx, field)
			case "connectionId":
				return ec.fieldContext_TransferProgressEvent_connectionId(ctx, field)
			case "transfers":
				return ec.fieldContext_TransferProgressEvent_transfers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransferProgressEvent", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_transferProgress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_name(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_sourcePath(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_sourcePath,
		func(ctx context.Context) (any, error) {
			return obj.SourcePath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_sourcePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_remotePath,
		func(ctx context.Context) (any, error) {
			return obj.RemotePath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_direction(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_direction,
		func(ctx context.Context) (any, error) {
			return obj.Direction, nil
		},
		nil,
		ec.marshalNSyncDirection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_direction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SyncDirection does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_schedule(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_schedule,
		func(ctx context.Context) (any, error) {
			return obj.Schedule, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_schedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_realtime(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_realtime,
		func(ctx context.Context) (any, error) {
			return obj.Realtime, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_realtime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_options(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_options,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Options(ctx, obj)
		},
		nil,
		ec.marshalOTaskSyncOptions2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskSyncOptions,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "conflictResolution":
				return ec.fieldContext_TaskSyncOptions_conflictResolution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSyncOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_createdAt,
		func(ctx context.Context) (any, error) {
			return obj.CreatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_updatedAt,
		func(ctx context.Context) (any, error) {
			return obj.UpdatedAt, nil
		},
		nil,
		ec.marshalNDateTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_connection(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_connection,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Connection(ctx, obj)
		},
		nil,
		ec.marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_connection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Connection_id(ctx, field)
			case "name":
				return ec.fieldContext_Connection_name(ctx, field)
			case "type":
				return ec.fieldContext_Connection_type(ctx, field)
			case "config":
				return ec.fieldContext_Connection_config(ctx, field)
			case "loadStatus":
				return ec.fieldContext_Connection_loadStatus(ctx, field)
			case "loadError":
				return ec.fieldContext_Connection_loadError(ctx, field)
			case "createdAt":
				return ec.fieldContext_Connection_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Connection_updatedAt(ctx, field)
			case "tasks":
				return ec.fieldContext_Connection_tasks(ctx, field)
			case "quota":
				return ec.fieldContext_Connection_quota(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Connection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_jobs(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_jobs,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Task().Jobs(ctx, obj, fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNJobConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_jobs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_JobConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_JobConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_JobConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JobConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Task_jobs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_latestJob(ctx context.Context, field graphql.CollectedField, obj *model.Task) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_latestJob,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().LatestJob(ctx, obj)
		},
		nil,
		ec.marshalOJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_latestJob(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "trigger":
				return ec.fieldContext_Job_trigger(ctx, field)
			case "startTime":
				return ec.fieldContext_Job_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Job_endTime(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_Job_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_Job_bytesTransferred(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_Job_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_Job_errorCount(ctx, field)
			case "errors":
				return ec.fieldContext_Job_errors(ctx, field)
			case "task":
				return ec.fieldContext_Job_task(ctx, field)
			case "logs":
				return ec.fieldContext_Job_logs(ctx, field)
			case "progress":
				return ec.fieldContext_Job_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_items(ctx context.Context, field graphql.CollectedField, obj *model.TaskConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskConnection_items,
		func(ctx context.Context) (any, error) {
			return obj.Items, nil
		},
		nil,
		ec.marshalNTask2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskConnection_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.TaskConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskConnection_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.TaskConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskConnection_pageInfo,
		func(ctx context.Context) (any, error) {
			return obj.PageInfo, nil
		},
		nil,
		ec.marshalNOffsetPageInfo2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOffsetPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "limit":
				return ec.fieldContext_OffsetPageInfo_limit(ctx, field)
			case "offset":
				return ec.fieldContext_OffsetPageInfo_offset(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_OffsetPageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_OffsetPageInfo_hasPreviousPage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OffsetPageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskMutation_create(ctx context.Context, field graphql.CollectedField, obj *model.TaskMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskMutation_create,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskMutation().Create(ctx, obj, fc.Args["input"].(model.CreateTaskInput))
		},
		nil,
		ec.marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskMutation_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskMutation_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskMutation_update(ctx context.Context, field graphql.CollectedField, obj *model.TaskMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskMutation_update,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskMutation().Update(ctx, obj, fc.Args["id"].(uuid.UUID), fc.Args["input"].(model.UpdateTaskInput))
		},
		nil,
		ec.marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskMutation_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskMutation_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskMutation_delete(ctx context.Context, field graphql.CollectedField, obj *model.TaskMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskMutation_delete,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskMutation().Delete(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskMutation_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskMutation_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskMutation_run(ctx context.Context, field graphql.CollectedField, obj *model.TaskMutation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskMutation_run,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskMutation().Run(ctx, obj, fc.Args["taskId"].(uuid.UUID))
		},
		nil,
		ec.marshalNJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskMutation_run(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskMutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Job_id(ctx, field)
			case "status":
				return ec.fieldContext_Job_status(ctx, field)
			case "trigger":
				return ec.fieldContext_Job_trigger(ctx, field)
			case "startTime":
				return ec.fieldContext_Job_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_Job_endTime(ctx, field)
			case "filesTransferred":
				return ec.fieldContext_Job_filesTransferred(ctx, field)
			case "bytesTransferred":
				return ec.fieldContext_Job_bytesTransferred(ctx, field)
			case "filesDeleted":
				return ec.fieldContext_Job_filesDeleted(ctx, field)
			case "errorCount":
				return ec.fieldContext_Job_errorCount(ctx, field)
			case "errors":
				return ec.fieldContext_Job_errors(ctx, field)
			case "task":
				return ec.fieldContext_Job_task(ctx, field)
			case "logs":
				return ec.fieldContext_Job_logs(ctx, field)
			case "progress":
				return ec.fieldContext_Job_progress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Job", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskMutation_run_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskQuery_list(ctx context.Context, field graphql.CollectedField, obj *model.TaskQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQuery_list,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskQuery().List(ctx, obj, fc.Args["pagination"].(*model.PaginationInput))
		},
		nil,
		ec.marshalNTaskConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskConnection,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQuery_list(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "items":
				return ec.fieldContext_TaskConnection_items(ctx, field)
			case "totalCount":
				return ec.fieldContext_TaskConnection_totalCount(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TaskConnection_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskQuery_list_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskQuery_get(ctx context.Context, field graphql.CollectedField, obj *model.TaskQuery) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQuery_get,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.TaskQuery().Get(ctx, obj, fc.Args["id"].(uuid.UUID))
		},
		nil,
		ec.marshalOTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskQuery_get(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQuery",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "name":
				return ec.fieldContext_Task_name(ctx, field)
			case "sourcePath":
				return ec.fieldContext_Task_sourcePath(ctx, field)
			case "remotePath":
				return ec.fieldContext_Task_remotePath(ctx, field)
			case "direction":
				return ec.fieldContext_Task_direction(ctx, field)
			case "schedule":
				return ec.fieldContext_Task_schedule(ctx, field)
			case "realtime":
				return ec.fieldContext_Task_realtime(ctx, field)
			case "options":
				return ec.fieldContext_Task_options(ctx, field)
			case "createdAt":
				return ec.fieldContext_Task_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Task_updatedAt(ctx, field)
			case "connection":
				return ec.fieldContext_Task_connection(ctx, field)
			case "jobs":
				return ec.fieldContext_Task_jobs(ctx, field)
			case "latestJob":
				return ec.fieldContext_Task_latestJob(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_TaskQuery_get_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TaskSyncOptions_conflictResolution(ctx context.Context, field graphql.CollectedField, obj *model.TaskSyncOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskSyncOptions_conflictResolution,
		func(ctx context.Context) (any, error) {
			return obj.ConflictResolution, nil
		},
		nil,
		ec.marshalOConflictResolution2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConflictResolution,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskSyncOptions_conflictResolution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSyncOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ConflictResolution does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferItem_name(ctx context.Context, field graphql.CollectedField, obj *model.TransferItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferItem_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferItem_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferItem_size(ctx context.Context, field graphql.CollectedField, obj *model.TransferItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferItem_size,
		func(ctx context.Context) (any, error) {
			return obj.Size, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferItem_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferItem_bytes(ctx context.Context, field graphql.CollectedField, obj *model.TransferItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferItem_bytes,
		func(ctx context.Context) (any, error) {
			return obj.Bytes, nil
		},
		nil,
		ec.marshalNBigInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferItem_bytes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferProgressEvent_jobId(ctx context.Context, field graphql.CollectedField, obj *model.TransferProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferProgressEvent_jobId,
		func(ctx context.Context) (any, error) {
			return obj.JobID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferProgressEvent_jobId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferProgressEvent_taskId(ctx context.Context, field graphql.CollectedField, obj *model.TransferProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferProgressEvent_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferProgressEvent_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferProgressEvent_connectionId(ctx context.Context, field graphql.CollectedField, obj *model.TransferProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferProgressEvent_connectionId,
		func(ctx context.Context) (any, error) {
			return obj.ConnectionID, nil
		},
		nil,
		ec.marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferProgressEvent_connectionId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransferProgressEvent_transfers(ctx context.Context, field graphql.CollectedField, obj *model.TransferProgressEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransferProgressEvent_transfers,
		func(ctx context.Context) (any, error) {
			return obj.Transfers, nil
		},
		nil,
		ec.marshalNTransferItem2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferItemᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransferProgressEvent_transfers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransferProgressEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_TransferItem_name(ctx, field)
			case "size":
				return ec.fieldContext_TransferItem_size(ctx, field)
			case "bytes":
				return ec.fieldContext_TransferItem_bytes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransferItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateConnectionInput(ctx context.Context, obj any) (model.CreateConnectionInput, error) {
	var it model.CreateConnectionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Config = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTaskInput(ctx context.Context, obj any) (model.CreateTaskInput, error) {
	var it model.CreateTaskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["realtime"]; !present {
		asMap["realtime"] = false
	}

	fieldsInOrder := [...]string{"name", "sourcePath", "connectionId", "remotePath", "direction", "schedule", "realtime", "options"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sourcePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourcePath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourcePath = data
		case "connectionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectionId"))
			data, err := ec.unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectionID = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSyncDirection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "schedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedule"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Schedule = data
		case "realtime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("realtime"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Realtime = data
		case "options":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			data, err := ec.unmarshalOTaskSyncOptionsInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskSyncOptionsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Options = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImportConnectionInput(ctx context.Context, obj any) (model.ImportConnectionInput, error) {
	var it model.ImportConnectionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "type", "config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Config = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImportExecuteInput(ctx context.Context, obj any) (model.ImportExecuteInput, error) {
	var it model.ImportExecuteInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"connections"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "connections":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connections"))
			data, err := ec.unmarshalNImportConnectionInput2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportConnectionInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Connections = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImportParseInput(ctx context.Context, obj any) (model.ImportParseInput, error) {
	var it model.ImportParseInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"content"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "content":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("content"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Content = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationInput(ctx context.Context, obj any) (model.PaginationInput, error) {
	var it model.PaginationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 20
	}
	if _, present := asMap["offset"]; !present {
		asMap["offset"] = 0
	}

	fieldsInOrder := [...]string{"limit", "offset"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSyncOptionsInput(ctx context.Context, obj any) (model.TaskSyncOptionsInput, error) {
	var it model.TaskSyncOptionsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"conflictResolution"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "conflictResolution":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conflictResolution"))
			data, err := ec.unmarshalOConflictResolution2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConflictResolution(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConflictResolution = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestConnectionInput(ctx context.Context, obj any) (model.TestConnectionInput, error) {
	var it model.TestConnectionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Config = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateConnectionInput(ctx context.Context, obj any) (model.UpdateConnectionInput, error) {
	var it model.UpdateConnectionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "config"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "config":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("config"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Config = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTaskInput(ctx context.Context, obj any) (model.UpdateTaskInput, error) {
	var it model.UpdateTaskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "sourcePath", "connectionId", "remotePath", "direction", "schedule", "realtime", "options"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sourcePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sourcePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourcePath = data
		case "connectionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectionId"))
			data, err := ec.unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConnectionID = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalOSyncDirection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "schedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedule"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Schedule = data
		case "realtime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("realtime"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Realtime = data
		case "options":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			data, err := ec.unmarshalOTaskSyncOptionsInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskSyncOptionsInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Options = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ImportParseResult(ctx context.Context, sel ast.SelectionSet, obj model.ImportParseResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ImportParseSuccess:
		return ec._ImportParseSuccess(ctx, sel, &obj)
	case *model.ImportParseSuccess:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImportParseSuccess(ctx, sel, obj)
	case model.ImportParseError:
		return ec._ImportParseError(ctx, sel, &obj)
	case *model.ImportParseError:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImportParseError(ctx, sel, obj)
	default:
		if obj, ok := obj.(graphql.Marshaler); ok {
			return obj
		} else {
			panic(fmt.Errorf("unexpected type %T; non-generated variants of ImportParseResult must implement graphql.Marshaler", obj))
		}
	}
}

func (ec *executionContext) _TestConnectionResult(ctx context.Context, sel ast.SelectionSet, obj model.TestConnectionResult) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.ConnectionTestSuccess:
		return ec._ConnectionTestSuccess(ctx, sel, &obj)
	case *model.ConnectionTestSuccess:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConnectionTestSuccess(ctx, sel, obj)
	case model.ConnectionTestFailure:
		return ec._ConnectionTestFailure(ctx, sel, &obj)
	case *model.ConnectionTestFailure:
		if obj == nil {
			return graphql.Null
		}
		return ec._ConnectionTestFailure(ctx, sel, obj)
	default:
		if obj, ok := obj.(graphql.Marshaler); ok {
			return obj
		} else {
			panic(fmt.Errorf("unexpected type %T; non-generated variants of TestConnectionResult must implement graphql.Marshaler", obj))
		}
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var connectionImplementors = []string{"Connection"}

func (ec *executionContext) _Connection(ctx context.Context, sel ast.SelectionSet, obj *model.Connection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Connection")
		case "id":
			out.Values[i] = ec._Connection_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Connection_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Connection_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Connection_config(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "loadStatus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Connection_loadStatus(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "loadError":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Connection_loadError(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Connection_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Connection_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Connection_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "quota":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Connection_quota(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionConnectionImplementors = []string{"ConnectionConnection"}

func (ec *executionContext) _ConnectionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionConnection")
		case "items":
			out.Values[i] = ec._ConnectionConnection_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ConnectionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._ConnectionConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionMutationImplementors = []string{"ConnectionMutation"}

func (ec *executionContext) _ConnectionMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "delete":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionMutation_delete(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "test":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionMutation_test(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "testUnsaved":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionMutation_testUnsaved(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionQueryImplementors = []string{"ConnectionQuery"}

func (ec *executionContext) _ConnectionQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionQuery")
		case "list":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionQuery_list(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "get":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConnectionQuery_get(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionQuotaImplementors = []string{"ConnectionQuota"}

func (ec *executionContext) _ConnectionQuota(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionQuota) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionQuotaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionQuota")
		case "total":
			out.Values[i] = ec._ConnectionQuota_total(ctx, field, obj)
		case "used":
			out.Values[i] = ec._ConnectionQuota_used(ctx, field, obj)
		case "free":
			out.Values[i] = ec._ConnectionQuota_free(ctx, field, obj)
		case "trashed":
			out.Values[i] = ec._ConnectionQuota_trashed(ctx, field, obj)
		case "other":
			out.Values[i] = ec._ConnectionQuota_other(ctx, field, obj)
		case "objects":
			out.Values[i] = ec._ConnectionQuota_objects(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionTestFailureImplementors = []string{"ConnectionTestFailure", "TestConnectionResult"}

func (ec *executionContext) _ConnectionTestFailure(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionTestFailure) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionTestFailureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionTestFailure")
		case "error":
			out.Values[i] = ec._ConnectionTestFailure_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectionTestSuccessImplementors = []string{"ConnectionTestSuccess", "TestConnectionResult"}

func (ec *executionContext) _ConnectionTestSuccess(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectionTestSuccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionTestSuccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectionTestSuccess")
		case "message":
			out.Values[i] = ec._ConnectionTestSuccess_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileEntryImplementors = []string{"FileEntry"}

func (ec *executionContext) _FileEntry(ctx context.Context, sel ast.SelectionSet, obj *model.FileEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileEntry")
		case "name":
			out.Values[i] = ec._FileEntry_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._FileEntry_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDir":
			out.Values[i] = ec._FileEntry_isDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileQueryImplementors = []string{"FileQuery"}

func (ec *executionContext) _FileQuery(ctx context.Context, sel ast.SelectionSet, obj *model.FileQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileQuery")
		case "local":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileQuery_local(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "remote":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileQuery_remote(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importExecuteResultImplementors = []string{"ImportExecuteResult"}

func (ec *executionContext) _ImportExecuteResult(ctx context.Context, sel ast.SelectionSet, obj *model.ImportExecuteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importExecuteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportExecuteResult")
		case "connections":
			out.Values[i] = ec._ImportExecuteResult_connections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "skippedCount":
			out.Values[i] = ec._ImportExecuteResult_skippedCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importMutationImplementors = []string{"ImportMutation"}

func (ec *executionContext) _ImportMutation(ctx context.Context, sel ast.SelectionSet, obj *model.ImportMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportMutation")
		case "parse":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImportMutation_parse(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execute":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ImportMutation_execute(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importParseErrorImplementors = []string{"ImportParseError", "ImportParseResult"}

func (ec *executionContext) _ImportParseError(ctx context.Context, sel ast.SelectionSet, obj *model.ImportParseError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importParseErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportParseError")
		case "error":
			out.Values[i] = ec._ImportParseError_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "line":
			out.Values[i] = ec._ImportParseError_line(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var importParseSuccessImplementors = []string{"ImportParseSuccess", "ImportParseResult"}

func (ec *executionContext) _ImportParseSuccess(ctx context.Context, sel ast.SelectionSet, obj *model.ImportParseSuccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, importParseSuccessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImportParseSuccess")
		case "connections":
			out.Values[i] = ec._ImportParseSuccess_connections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobImplementors = []string{"Job"}

func (ec *executionContext) _Job(ctx context.Context, sel ast.SelectionSet, obj *model.Job) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Job")
		case "id":
			out.Values[i] = ec._Job_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Job_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "trigger":
			out.Values[i] = ec._Job_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Job_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "endTime":
			out.Values[i] = ec._Job_endTime(ctx, field, obj)
		case "filesTransferred":
			out.Values[i] = ec._Job_filesTransferred(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bytesTransferred":
			out.Values[i] = ec._Job_bytesTransferred(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "filesDeleted":
			out.Values[i] = ec._Job_filesDeleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errorCount":
			out.Values[i] = ec._Job_errorCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errors":
			out.Values[i] = ec._Job_errors(ctx, field, obj)
		case "task":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_task(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_logs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "progress":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Job_progress(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobConnectionImplementors = []string{"JobConnection"}

func (ec *executionContext) _JobConnection(ctx context.Context, sel ast.SelectionSet, obj *model.JobConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobConnection")
		case "items":
			out.Values[i] = ec._JobConnection_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._JobConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._JobConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobLogImplementors = []string{"JobLog"}

func (ec *executionContext) _JobLog(ctx context.Context, sel ast.SelectionSet, obj *model.JobLog) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobLog")
		case "id":
			out.Values[i] = ec._JobLog_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level":
			out.Values[i] = ec._JobLog_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "time":
			out.Values[i] = ec._JobLog_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "path":
			out.Values[i] = ec._JobLog_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "what":
			out.Values[i] = ec._JobLog_what(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._JobLog_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "job":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JobLog_job(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobLogConnectionImplementors = []string{"JobLogConnection"}

func (ec *executionContext) _JobLogConnection(ctx context.Context, sel ast.SelectionSet, obj *model.JobLogConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobLogConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobLogConnection")
		case "items":
			out.Values[i] = ec._JobLogConnection_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._JobLogConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._JobLogConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobProgressEventImplementors = []string{"JobProgressEvent"}

func (ec *executionContext) _JobProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.JobProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobProgressEvent")
		case "jobId":
			out.Values[i] = ec._JobProgressEvent_jobId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._JobProgressEvent_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectionId":
			out.Values[i] = ec._JobProgressEvent_connectionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._JobProgressEvent_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filesTransferred":
			out.Values[i] = ec._JobProgressEvent_filesTransferred(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytesTransferred":
			out.Values[i] = ec._JobProgressEvent_bytesTransferred(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filesTotal":
			out.Values[i] = ec._JobProgressEvent_filesTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytesTotal":
			out.Values[i] = ec._JobProgressEvent_bytesTotal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filesDeleted":
			out.Values[i] = ec._JobProgressEvent_filesDeleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errorCount":
			out.Values[i] = ec._JobProgressEvent_errorCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._JobProgressEvent_startTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endTime":
			out.Values[i] = ec._JobProgressEvent_endTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jobQueryImplementors = []string{"JobQuery"}

func (ec *executionContext) _JobQuery(ctx context.Context, sel ast.SelectionSet, obj *model.JobQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jobQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JobQuery")
		case "list":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JobQuery_list(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "get":
			out.Values[i] = ec._JobQuery_get(ctx, field, obj)
		case "progress":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JobQuery_progress(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logQueryImplementors = []string{"LogQuery"}

func (ec *executionContext) _LogQuery(ctx context.Context, sel ast.SelectionSet, obj *model.LogQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogQuery")
		case "list":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogQuery_list(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "connection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_connection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "import":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_import(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_task(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var offsetPageInfoImplementors = []string{"OffsetPageInfo"}

func (ec *executionContext) _OffsetPageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.OffsetPageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, offsetPageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OffsetPageInfo")
		case "limit":
			out.Values[i] = ec._OffsetPageInfo_limit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "offset":
			out.Values[i] = ec._OffsetPageInfo_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._OffsetPageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._OffsetPageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var optionExampleImplementors = []string{"OptionExample"}

func (ec *executionContext) _OptionExample(ctx context.Context, sel ast.SelectionSet, obj *model.OptionExample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, optionExampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OptionExample")
		case "value":
			out.Values[i] = ec._OptionExample_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "help":
			out.Values[i] = ec._OptionExample_help(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsedConnectionImplementors = []string{"ParsedConnection"}

func (ec *executionContext) _ParsedConnection(ctx context.Context, sel ast.SelectionSet, obj *model.ParsedConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsedConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsedConnection")
		case "name":
			out.Values[i] = ec._ParsedConnection_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ParsedConnection_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "config":
			out.Values[i] = ec._ParsedConnection_config(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerImplementors = []string{"Provider"}

func (ec *executionContext) _Provider(ctx context.Context, sel ast.SelectionSet, obj *model.Provider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Provider")
		case "name":
			out.Values[i] = ec._Provider_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Provider_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prefix":
			out.Values[i] = ec._Provider_prefix(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "options":
			out.Values[i] = ec._Provider_options(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerOptionImplementors = []string{"ProviderOption"}

func (ec *executionContext) _ProviderOption(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderOption) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerOptionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderOption")
		case "name":
			out.Values[i] = ec._ProviderOption_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "help":
			out.Values[i] = ec._ProviderOption_help(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "required":
			out.Values[i] = ec._ProviderOption_required(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPassword":
			out.Values[i] = ec._ProviderOption_isPassword(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "default":
			out.Values[i] = ec._ProviderOption_default(ctx, field, obj)
		case "examples":
			out.Values[i] = ec._ProviderOption_examples(ctx, field, obj)
		case "advanced":
			out.Values[i] = ec._ProviderOption_advanced(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groups":
			out.Values[i] = ec._ProviderOption_groups(ctx, field, obj)
		case "exclusive":
			out.Values[i] = ec._ProviderOption_exclusive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ProviderOption_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var providerQueryImplementors = []string{"ProviderQuery"}

func (ec *executionContext) _ProviderQuery(ctx context.Context, sel ast.SelectionSet, obj *model.ProviderQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, providerQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProviderQuery")
		case "list":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderQuery_list(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "get":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProviderQuery_get(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "connection":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "file":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_file(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "job":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_job(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "log":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_log(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "provider":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provider(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "jobProgress":
		return ec._Subscription_jobProgress(ctx, fields[0])
	case "transferProgress":
		return ec._Subscription_transferProgress(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Task_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sourcePath":
			out.Values[i] = ec._Task_sourcePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remotePath":
			out.Values[i] = ec._Task_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "direction":
			out.Values[i] = ec._Task_direction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "schedule":
			out.Values[i] = ec._Task_schedule(ctx, field, obj)
		case "realtime":
			out.Values[i] = ec._Task_realtime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "options":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_options(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Task_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Task_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "connection":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_connection(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "jobs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_jobs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestJob":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_latestJob(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskConnectionImplementors = []string{"TaskConnection"}

func (ec *executionContext) _TaskConnection(ctx context.Context, sel ast.SelectionSet, obj *model.TaskConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskConnection")
		case "items":
			out.Values[i] = ec._TaskConnection_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TaskConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pageInfo":
			out.Values[i] = ec._TaskConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskMutationImplementors = []string{"TaskMutation"}

func (ec *executionContext) _TaskMutation(ctx context.Context, sel ast.SelectionSet, obj *model.TaskMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskMutationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskMutation")
		case "create":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskMutation_create(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "update":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskMutation_update(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "delete":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskMutation_delete(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "run":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskMutation_run(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueryImplementors = []string{"TaskQuery"}

func (ec *executionContext) _TaskQuery(ctx context.Context, sel ast.SelectionSet, obj *model.TaskQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQuery")
		case "list":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskQuery_list(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "get":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskQuery_get(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSyncOptionsImplementors = []string{"TaskSyncOptions"}

func (ec *executionContext) _TaskSyncOptions(ctx context.Context, sel ast.SelectionSet, obj *model.TaskSyncOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSyncOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSyncOptions")
		case "conflictResolution":
			out.Values[i] = ec._TaskSyncOptions_conflictResolution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transferItemImplementors = []string{"TransferItem"}

func (ec *executionContext) _TransferItem(ctx context.Context, sel ast.SelectionSet, obj *model.TransferItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transferItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransferItem")
		case "name":
			out.Values[i] = ec._TransferItem_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._TransferItem_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bytes":
			out.Values[i] = ec._TransferItem_bytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transferProgressEventImplementors = []string{"TransferProgressEvent"}

func (ec *executionContext) _TransferProgressEvent(ctx context.Context, sel ast.SelectionSet, obj *model.TransferProgressEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transferProgressEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransferProgressEvent")
		case "jobId":
			out.Values[i] = ec._TransferProgressEvent_jobId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TransferProgressEvent_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectionId":
			out.Values[i] = ec._TransferProgressEvent_connectionId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "transfers":
			out.Values[i] = ec._TransferProgressEvent_transfers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBigInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBigInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNConnection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection(ctx context.Context, sel ast.SelectionSet, v model.Connection) graphql.Marshaler {
	return ec._Connection(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnection2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Connection) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection(ctx context.Context, sel ast.SelectionSet, v *model.Connection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Connection(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectionConnection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionConnection(ctx context.Context, sel ast.SelectionSet, v model.ConnectionConnection) graphql.Marshaler {
	return ec._ConnectionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionConnection(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionLoadStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionLoadStatus(ctx context.Context, v any) (model.ConnectionLoadStatus, error) {
	var res model.ConnectionLoadStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnectionLoadStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionLoadStatus(ctx context.Context, sel ast.SelectionSet, v model.ConnectionLoadStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNConnectionMutation2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionMutation(ctx context.Context, sel ast.SelectionSet, v model.ConnectionMutation) graphql.Marshaler {
	return ec._ConnectionMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionMutation(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectionQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionQuery(ctx context.Context, sel ast.SelectionSet, v model.ConnectionQuery) graphql.Marshaler {
	return ec._ConnectionQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnectionQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionQuery(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectionQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐCreateConnectionInput(ctx context.Context, v any) (model.CreateConnectionInput, error) {
	res, err := ec.unmarshalInputCreateConnectionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTaskInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐCreateTaskInput(ctx context.Context, v any) (model.CreateTaskInput, error) {
	res, err := ec.unmarshalInputCreateTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDateTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNFileEntry2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FileEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFileEntry2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFileEntry2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileEntry(ctx context.Context, sel ast.SelectionSet, v *model.FileEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FileEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNFileQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileQuery(ctx context.Context, sel ast.SelectionSet, v model.FileQuery) graphql.Marshaler {
	return ec._FileQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNFileQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐFileQuery(ctx context.Context, sel ast.SelectionSet, v *model.FileQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FileQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v any) (uuid.UUID, error) {
	res, err := graphql.UnmarshalUUID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2githubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v uuid.UUID) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalUUID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImportConnectionInput2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportConnectionInputᚄ(ctx context.Context, v any) ([]*model.ImportConnectionInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ImportConnectionInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNImportConnectionInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportConnectionInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNImportConnectionInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportConnectionInput(ctx context.Context, v any) (*model.ImportConnectionInput, error) {
	res, err := ec.unmarshalInputImportConnectionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNImportExecuteInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportExecuteInput(ctx context.Context, v any) (model.ImportExecuteInput, error) {
	res, err := ec.unmarshalInputImportExecuteInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImportExecuteResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportExecuteResult(ctx context.Context, sel ast.SelectionSet, v model.ImportExecuteResult) graphql.Marshaler {
	return ec._ImportExecuteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNImportExecuteResult2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportExecuteResult(ctx context.Context, sel ast.SelectionSet, v *model.ImportExecuteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImportExecuteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNImportMutation2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportMutation(ctx context.Context, sel ast.SelectionSet, v model.ImportMutation) graphql.Marshaler {
	return ec._ImportMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNImportMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportMutation(ctx context.Context, sel ast.SelectionSet, v *model.ImportMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImportMutation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImportParseInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportParseInput(ctx context.Context, v any) (model.ImportParseInput, error) {
	res, err := ec.unmarshalInputImportParseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImportParseResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐImportParseResult(ctx context.Context, sel ast.SelectionSet, v model.ImportParseResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImportParseResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNJob2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob(ctx context.Context, sel ast.SelectionSet, v model.Job) graphql.Marshaler {
	return ec._Job(ctx, sel, &v)
}

func (ec *executionContext) marshalNJob2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Job) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob(ctx context.Context, sel ast.SelectionSet, v *model.Job) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Job(ctx, sel, v)
}

func (ec *executionContext) marshalNJobConnection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobConnection(ctx context.Context, sel ast.SelectionSet, v model.JobConnection) graphql.Marshaler {
	return ec._JobConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobConnection(ctx context.Context, sel ast.SelectionSet, v *model.JobConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobLog2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.JobLog) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJobLog2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLog(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJobLog2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLog(ctx context.Context, sel ast.SelectionSet, v *model.JobLog) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobLog(ctx, sel, v)
}

func (ec *executionContext) marshalNJobLogConnection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogConnection(ctx context.Context, sel ast.SelectionSet, v model.JobLogConnection) graphql.Marshaler {
	return ec._JobLogConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobLogConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobLogConnection(ctx context.Context, sel ast.SelectionSet, v *model.JobLogConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobLogConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNJobProgressEvent2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.JobProgressEvent) graphql.Marshaler {
	return ec._JobProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.JobProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobProgressEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNJobQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobQuery(ctx context.Context, sel ast.SelectionSet, v model.JobQuery) graphql.Marshaler {
	return ec._JobQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNJobQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobQuery(ctx context.Context, sel ast.SelectionSet, v *model.JobQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JobQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJobStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobStatus(ctx context.Context, v any) (model.JobStatus, error) {
	var res model.JobStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobStatus2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobStatus(ctx context.Context, sel ast.SelectionSet, v model.JobStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNJobTrigger2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobTrigger(ctx context.Context, v any) (model.JobTrigger, error) {
	var res model.JobTrigger
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJobTrigger2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobTrigger(ctx context.Context, sel ast.SelectionSet, v model.JobTrigger) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLogAction2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogAction(ctx context.Context, v any) (model.LogAction, error) {
	var res model.LogAction
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLogAction2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogAction(ctx context.Context, sel ast.SelectionSet, v model.LogAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLogLevel2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel(ctx context.Context, v any) (model.LogLevel, error) {
	var res model.LogLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLogLevel2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel(ctx context.Context, sel ast.SelectionSet, v model.LogLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLogQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogQuery(ctx context.Context, sel ast.SelectionSet, v model.LogQuery) graphql.Marshaler {
	return ec._LogQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogQuery(ctx context.Context, sel ast.SelectionSet, v *model.LogQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogQuery(ctx, sel, v)
}

func (ec *executionContext) marshalNOffsetPageInfo2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOffsetPageInfo(ctx context.Context, sel ast.SelectionSet, v *model.OffsetPageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OffsetPageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNOptionExample2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOptionExample(ctx context.Context, sel ast.SelectionSet, v *model.OptionExample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OptionExample(ctx, sel, v)
}

func (ec *executionContext) marshalNParsedConnection2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐParsedConnectionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ParsedConnection) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsedConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐParsedConnection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParsedConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐParsedConnection(ctx context.Context, sel ast.SelectionSet, v *model.ParsedConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ParsedConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNProvider2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Provider) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProvider2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProvider2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) marshalNProviderOption2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderOptionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ProviderOption) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProviderOption2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProviderOption2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderOption(ctx context.Context, sel ast.SelectionSet, v *model.ProviderOption) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProviderOption(ctx, sel, v)
}

func (ec *executionContext) marshalNProviderQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderQuery(ctx context.Context, sel ast.SelectionSet, v model.ProviderQuery) graphql.Marshaler {
	return ec._ProviderQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNProviderQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProviderQuery(ctx context.Context, sel ast.SelectionSet, v *model.ProviderQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProviderQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	res, err := scalar.UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := scalar.MarshalStringMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNSyncDirection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx context.Context, v any) (model.SyncDirection, error) {
	var res model.SyncDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSyncDirection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx context.Context, sel ast.SelectionSet, v model.SyncDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTask2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v model.Task) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Task) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v *model.Task) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskConnection2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskConnection(ctx context.Context, sel ast.SelectionSet, v model.TaskConnection) graphql.Marshaler {
	return ec._TaskConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskConnection(ctx context.Context, sel ast.SelectionSet, v *model.TaskConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskMutation2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskMutation(ctx context.Context, sel ast.SelectionSet, v model.TaskMutation) graphql.Marshaler {
	return ec._TaskMutation(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskMutation2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskMutation(ctx context.Context, sel ast.SelectionSet, v *model.TaskMutation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskMutation(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQuery2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskQuery(ctx context.Context, sel ast.SelectionSet, v model.TaskQuery) graphql.Marshaler {
	return ec._TaskQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskQuery2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskQuery(ctx context.Context, sel ast.SelectionSet, v *model.TaskQuery) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTestConnectionInput(ctx context.Context, v any) (model.TestConnectionInput, error) {
	res, err := ec.unmarshalInputTestConnectionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestConnectionResult2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTestConnectionResult(ctx context.Context, sel ast.SelectionSet, v model.TestConnectionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestConnectionResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTransferItem2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TransferItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransferItem2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTransferItem2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferItem(ctx context.Context, sel ast.SelectionSet, v *model.TransferItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransferItem(ctx, sel, v)
}

func (ec *executionContext) marshalNTransferProgressEvent2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferProgressEvent(ctx context.Context, sel ast.SelectionSet, v model.TransferProgressEvent) graphql.Marshaler {
	return ec._TransferProgressEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransferProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTransferProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.TransferProgressEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransferProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateConnectionInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐUpdateConnectionInput(ctx context.Context, v any) (model.UpdateConnectionInput, error) {
	res, err := ec.unmarshalInputUpdateConnectionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTaskInput2githubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐUpdateTaskInput(ctx context.Context, v any) (model.UpdateTaskInput, error) {
	res, err := ec.unmarshalInputUpdateTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBigInt2ᚖint64(ctx context.Context, v any) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBigInt2ᚖint64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOConflictResolution2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConflictResolution(ctx context.Context, v any) (*model.ConflictResolution, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ConflictResolution)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOConflictResolution2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConflictResolution(ctx context.Context, sel ast.SelectionSet, v *model.ConflictResolution) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOConnection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnection(ctx context.Context, sel ast.SelectionSet, v *model.Connection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Connection(ctx, sel, v)
}

func (ec *executionContext) marshalOConnectionQuota2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐConnectionQuota(ctx context.Context, sel ast.SelectionSet, v *model.ConnectionQuota) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectionQuota(ctx, sel, v)
}

func (ec *executionContext) unmarshalODateTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, v any) (*uuid.UUID, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUUID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖgithubᚗcomᚋgoogleᚋuuidᚐUUID(ctx context.Context, sel ast.SelectionSet, v *uuid.UUID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUUID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOJob2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJob(ctx context.Context, sel ast.SelectionSet, v *model.Job) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Job(ctx, sel, v)
}

func (ec *executionContext) marshalOJobProgressEvent2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐJobProgressEvent(ctx context.Context, sel ast.SelectionSet, v *model.JobProgressEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JobProgressEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLogLevel2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel(ctx context.Context, v any) (*model.LogLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LogLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLogLevel2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐLogLevel(ctx context.Context, sel ast.SelectionSet, v *model.LogLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOOptionExample2ᚕᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOptionExampleᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.OptionExample) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOptionExample2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐOptionExample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPaginationInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐPaginationInput(ctx context.Context, v any) (*model.PaginationInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPaginationInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProvider2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐProvider(ctx context.Context, sel ast.SelectionSet, v *model.Provider) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Provider(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalar.UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := scalar.MarshalStringMap(v)
	return res
}

func (ec *executionContext) unmarshalOSyncDirection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx context.Context, v any) (*model.SyncDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.SyncDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSyncDirection2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐSyncDirection(ctx context.Context, sel ast.SelectionSet, v *model.SyncDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOTask2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTask(ctx context.Context, sel ast.SelectionSet, v *model.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskSyncOptions2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskSyncOptions(ctx context.Context, sel ast.SelectionSet, v *model.TaskSyncOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskSyncOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskSyncOptionsInput2ᚖgithubᚗcomᚋxzzpigᚋrcloneᚑsyncᚋinternalᚋapiᚋgraphqlᚋmodelᚐTaskSyncOptionsInput(ctx context.Context, v any) (*model.TaskSyncOptionsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskSyncOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
