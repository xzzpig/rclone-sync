package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/google/uuid"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/core/logger"
	"github.com/xzzpig/rclone-sync/internal/i18n"
	"github.com/xzzpig/rclone-sync/internal/rclone"
	"go.uber.org/zap"
)

// Config is the resolver for the config field.
func (r *connectionResolver) Config(ctx context.Context, obj *model.Connection) (map[string]string, error) {
	return r.deps.ConnectionService.GetConnectionConfigByID(ctx, obj.ID)
}

// LoadStatus is the resolver for the loadStatus field.
func (r *connectionResolver) LoadStatus(ctx context.Context, obj *model.Connection) (model.ConnectionLoadStatus, error) {
	if rclone.IsConnectionLoaded(obj.Name) {
		return model.ConnectionLoadStatusLoaded, nil
	}
	// If not loaded, we consider it as "loading" status initially
	// This is a simplified implementation - in reality you might want to track loading state separately
	// TODO: Implement proper load status tracking
	return model.ConnectionLoadStatusLoading, nil
}

// LoadError is the resolver for the loadError field.
func (r *connectionResolver) LoadError(ctx context.Context, obj *model.Connection) (*string, error) {
	// Currently we don't persist load errors
	// Return nil to indicate no error
	// TODO: Implement proper load error tracking
	return nil, nil
}

// Tasks is the resolver for the tasks field.
func (r *connectionResolver) Tasks(ctx context.Context, obj *model.Connection, pagination *model.PaginationInput) (*model.TaskConnection, error) {
	// Default pagination values
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil {
			offset = *pagination.Offset
		}
	}

	// Use TaskService to list tasks by connection
	entTasks, totalCount, err := r.deps.TaskService.ListTasksByConnectionPaginated(ctx, obj.ID, limit, offset)
	if err != nil {
		return nil, err
	}

	// Convert ent tasks to model tasks
	items := make([]*model.Task, len(entTasks))
	for i, t := range entTasks {
		items[i] = entTaskToModel(t)
	}

	// Build page info
	hasNextPage := offset+len(items) < totalCount
	hasPreviousPage := offset > 0

	return &model.TaskConnection{
		Items:      items,
		TotalCount: totalCount,
		PageInfo: &model.OffsetPageInfo{
			Limit:           limit,
			Offset:          offset,
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
		},
	}, nil
}

// Quota is the resolver for the quota field.
func (r *connectionResolver) Quota(ctx context.Context, obj *model.Connection) (*model.ConnectionQuota, error) {
	quota, err := rclone.GetRemoteQuota(ctx, obj.Name)
	if err != nil {
		logger.Named("api.graphql.resolver.connection").Warn("Failed to get remote quota",
			zap.String("connection", obj.Name),
			zap.Error(err),
		)
		// Return nil quota on error (some remotes don't support quota)
		return nil, nil
	}

	return &model.ConnectionQuota{
		Total:   quota.Total,
		Used:    quota.Used,
		Free:    quota.Free,
		Trashed: quota.Trashed,
		Other:   quota.Other,
		Objects: quota.Objects,
	}, nil
}

// Create is the resolver for the create field.
func (r *connectionMutationResolver) Create(ctx context.Context, obj *model.ConnectionMutation, input model.CreateConnectionInput) (*model.Connection, error) {
	entConn, err := r.deps.ConnectionService.CreateConnection(ctx, input.Name, input.Type, input.Config)
	if err != nil {
		return nil, err
	}
	return entConnectionToModel(entConn), nil
}

// Update is the resolver for the update field.
func (r *connectionMutationResolver) Update(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID, input model.UpdateConnectionInput) (*model.Connection, error) {
	err := r.deps.ConnectionService.UpdateConnection(ctx, id, input.Name, nil, input.Config)
	if err != nil {
		return nil, err
	}

	// Fetch updated connection
	entConn, err := r.deps.ConnectionService.GetConnectionByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return entConnectionToModel(entConn), nil
}

// Delete is the resolver for the delete field.
func (r *connectionMutationResolver) Delete(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID) (*model.Connection, error) {
	// Get connection before delete to return it
	entConn, err := r.deps.ConnectionService.GetConnectionByID(ctx, id)
	if err != nil {
		return nil, err
	}
	conn := entConnectionToModel(entConn)

	// Check if connection has dependent tasks
	taskCount, err := r.deps.ConnectionService.CountAssociatedTasks(ctx, id)
	if err != nil {
		return nil, err
	}
	if taskCount > 0 {
		return nil, i18n.ErrBadRequestI18n(i18n.ErrConnectionHasDependentTasks)
	}

	err = r.deps.ConnectionService.DeleteConnectionByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// Test is the resolver for the test field.
func (r *connectionMutationResolver) Test(ctx context.Context, obj *model.ConnectionMutation, id uuid.UUID) (model.TestConnectionResult, error) {
	// Get connection to get its type
	entConn, err := r.deps.ConnectionService.GetConnectionByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get connection config
	config, err := r.deps.ConnectionService.GetConnectionConfigByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Test the remote configuration
	if err := rclone.TestRemote(ctx, entConn.Type, config); err != nil {
		//nolint:nilerr // Returning test failure as union result, not as error
		return &model.ConnectionTestFailure{
			Error: err.Error(),
		}, nil
	}

	return &model.ConnectionTestSuccess{
		Message: "Connection test successful",
	}, nil
}

// TestUnsaved is the resolver for the testUnsaved field.
func (r *connectionMutationResolver) TestUnsaved(ctx context.Context, obj *model.ConnectionMutation, input model.TestConnectionInput) (model.TestConnectionResult, error) {
	// Test the remote configuration
	if err := rclone.TestRemote(ctx, input.Type, input.Config); err != nil {
		//nolint:nilerr // Returning test failure as union result, not as error
		return &model.ConnectionTestFailure{
			Error: err.Error(),
		}, nil
	}

	return &model.ConnectionTestSuccess{
		Message: "Connection test successful",
	}, nil
}

// List is the resolver for the list field.
func (r *connectionQueryResolver) List(ctx context.Context, obj *model.ConnectionQuery, pagination *model.PaginationInput) (*model.ConnectionConnection, error) {
	// Default pagination values
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil {
			offset = *pagination.Offset
		}
	}

	// Use ConnectionService to list connections
	entConnections, totalCount, err := r.deps.ConnectionService.ListConnectionsPaginated(ctx, limit, offset)
	if err != nil {
		return nil, err
	}

	// Convert ent connections to model connections
	items := make([]*model.Connection, len(entConnections))
	for i, c := range entConnections {
		items[i] = entConnectionToModel(c)
	}

	// Build page info
	hasNextPage := offset+len(items) < totalCount
	hasPreviousPage := offset > 0

	return &model.ConnectionConnection{
		Items:      items,
		TotalCount: totalCount,
		PageInfo: &model.OffsetPageInfo{
			Limit:           limit,
			Offset:          offset,
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
		},
	}, nil
}

// Get is the resolver for the get field.
func (r *connectionQueryResolver) Get(ctx context.Context, obj *model.ConnectionQuery, id uuid.UUID) (*model.Connection, error) {
	entConnection, err := r.deps.ConnectionService.GetConnectionByID(ctx, id)
	if err != nil {
		//nolint:nilerr // Return nil for not found, this is valid for GraphQL nullable queries
		return nil, nil
	}
	return entConnectionToModel(entConnection), nil
}

// Connection is the resolver for the connection field.
func (r *mutationResolver) Connection(ctx context.Context) (*model.ConnectionMutation, error) {
	return &model.ConnectionMutation{}, nil
}

// Connection is the resolver for the connection field.
func (r *queryResolver) Connection(ctx context.Context) (*model.ConnectionQuery, error) {
	return &model.ConnectionQuery{}, nil
}

// Connection returns generated.ConnectionResolver implementation.
func (r *Resolver) Connection() generated.ConnectionResolver { return &connectionResolver{r} }

// ConnectionMutation returns generated.ConnectionMutationResolver implementation.
func (r *Resolver) ConnectionMutation() generated.ConnectionMutationResolver {
	return &connectionMutationResolver{r}
}

// ConnectionQuery returns generated.ConnectionQueryResolver implementation.
func (r *Resolver) ConnectionQuery() generated.ConnectionQueryResolver {
	return &connectionQueryResolver{r}
}

type connectionResolver struct{ *Resolver }
type connectionMutationResolver struct{ *Resolver }
type connectionQueryResolver struct{ *Resolver }
