package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/google/uuid"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/rclone"
)

// List is the resolver for the list field.
// It provides a unified interface for listing both local and remote directories.
// When connectionID is nil, it lists local filesystem.
// When connectionID is provided, it lists the remote via that connection.
func (r *fileQueryResolver) List(ctx context.Context, obj *model.FileQuery, connectionID *uuid.UUID, path string, basePath *string, filters []string, includeFiles *bool) ([]*model.FileEntry, error) {
	wantFiles := includeFiles != nil && *includeFiles

	// Determine remote name: empty for local, connection name for remote
	var remoteName string
	if connectionID != nil {
		conn, err := r.deps.ConnectionService.GetConnectionByID(ctx, *connectionID)
		if err != nil {
			return nil, err
		}
		remoteName = conn.Name
	}

	opts := rclone.ListRemoteDirOptions{
		RemoteName:   remoteName,
		Path:         path,
		Filters:      filters,
		IncludeFiles: wantFiles,
	}
	if basePath != nil {
		opts.BasePath = *basePath
	}

	entries, err := rclone.ListRemoteDir(ctx, opts)
	if err != nil {
		return nil, err
	}

	// Map rclone.DirEntry to model.FileEntry
	result := make([]*model.FileEntry, len(entries))
	for i, entry := range entries {
		result[i] = &model.FileEntry{
			Name:  entry.Name,
			Path:  entry.Path,
			IsDir: entry.IsDir,
		}
	}

	return result, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context) (*model.FileQuery, error) {
	return &model.FileQuery{}, nil
}

// FileQuery returns generated.FileQueryResolver implementation.
func (r *Resolver) FileQuery() generated.FileQueryResolver { return &fileQueryResolver{r} }

type fileQueryResolver struct{ *Resolver }
