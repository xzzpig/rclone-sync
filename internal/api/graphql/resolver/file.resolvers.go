package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"os"
	"path/filepath"

	"github.com/google/uuid"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/rclone"
)

// Local is the resolver for the local field.
func (r *fileQueryResolver) Local(ctx context.Context, obj *model.FileQuery, path string) ([]*model.FileEntry, error) {
	// Check if path exists and is a directory
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, err
		}
		return nil, err
	}

	if !info.IsDir() {
		return nil, err
	}

	// Read directory contents
	entries, err := os.ReadDir(path)
	if err != nil {
		return nil, err
	}

	// Map to FileEntry (directories only to match REST API behavior)
	var result []*model.FileEntry
	for _, entry := range entries {
		// Skip if not a directory
		if !entry.IsDir() {
			continue
		}

		result = append(result, &model.FileEntry{
			Name:  entry.Name(),
			Path:  filepath.Join(path, entry.Name()),
			IsDir: true,
		})
	}

	return result, nil
}

// Remote is the resolver for the remote field.
func (r *fileQueryResolver) Remote(ctx context.Context, obj *model.FileQuery, connectionID uuid.UUID, path string) ([]*model.FileEntry, error) {
	// Get connection by ID to retrieve the remote name
	conn, err := r.deps.ConnectionService.GetConnectionByID(ctx, connectionID)
	if err != nil {
		return nil, err
	}

	// List remote directory using rclone
	entries, err := rclone.ListRemoteDir(ctx, conn.Name, path)
	if err != nil {
		return nil, err
	}

	// Map rclone.DirEntry to model.FileEntry
	result := make([]*model.FileEntry, len(entries))
	for i, entry := range entries {
		result[i] = &model.FileEntry{
			Name:  entry.Name,
			Path:  entry.Path,
			IsDir: entry.IsDir,
		}
	}

	return result, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context) (*model.FileQuery, error) {
	return &model.FileQuery{}, nil
}

// FileQuery returns generated.FileQueryResolver implementation.
func (r *Resolver) FileQuery() generated.FileQueryResolver { return &fileQueryResolver{r} }

type fileQueryResolver struct{ *Resolver }
