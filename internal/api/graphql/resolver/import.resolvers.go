package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/rclone"
)

// Parse is the resolver for the parse field.
func (r *importMutationResolver) Parse(ctx context.Context, obj *model.ImportMutation, input model.ImportParseInput) (model.ImportParseResult, error) {
	// Parse rclone.conf content
	connections, err := rclone.ParseRcloneConf(input.Content)
	if err != nil {
		// Return parse error as business result (not GraphQL error)
		return &model.ImportParseError{
			Error: err.Error(),
		}, nil
	}

	// Convert to GraphQL model
	parsedConns := make([]*model.ParsedConnection, len(connections))
	for i, conn := range connections {
		parsedConns[i] = &model.ParsedConnection{
			Name:   conn.Name,
			Type:   conn.Type,
			Config: conn.Config,
		}
	}

	return &model.ImportParseSuccess{
		Connections: parsedConns,
	}, nil
}

// Execute is the resolver for the execute field.
func (r *importMutationResolver) Execute(ctx context.Context, obj *model.ImportMutation, input model.ImportExecuteInput) (*model.ImportExecuteResult, error) {
	if len(input.Connections) == 0 {
		return &model.ImportExecuteResult{
			Connections:  []*model.Connection{},
			SkippedCount: 0,
		}, nil
	}

	var importedConns []*model.Connection
	var skippedCount int

	for _, connInput := range input.Connections {
		// Check if connection already exists
		existing, err := r.deps.ConnectionService.GetConnectionByName(ctx, connInput.Name)
		if err == nil && existing != nil {
			// Connection exists, skip it
			skippedCount++
			continue
		}

		// Create new connection
		conn, err := r.deps.ConnectionService.CreateConnection(ctx, connInput.Name, connInput.Type, connInput.Config)
		if err != nil {
			return nil, err
		}

		// Convert ent.Connection to model.Connection (config will be resolved by Connection.Config resolver)
		importedConns = append(importedConns, &model.Connection{
			ID:        conn.ID,
			Name:      conn.Name,
			Type:      conn.Type,
			CreatedAt: conn.CreatedAt,
			UpdatedAt: conn.UpdatedAt,
		})
	}

	return &model.ImportExecuteResult{
		Connections:  importedConns,
		SkippedCount: skippedCount,
	}, nil
}

// Import is the resolver for the import field.
func (r *mutationResolver) Import(ctx context.Context) (*model.ImportMutation, error) {
	return &model.ImportMutation{}, nil
}

// ImportMutation returns generated.ImportMutationResolver implementation.
func (r *Resolver) ImportMutation() generated.ImportMutationResolver {
	return &importMutationResolver{r}
}

type importMutationResolver struct{ *Resolver }
