package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/rclone"
)

// Parse is the resolver for the parse field.
func (r *importMutationResolver) Parse(ctx context.Context, obj *model.ImportMutation, input model.ImportParseInput) (model.ImportParseResult, error) {
	// Parse rclone.conf content
	connections, err := rclone.ParseRcloneConf(input.Content)
	if err != nil {
		//nolint:nilerr // Return parse error as union result, not as GraphQL error
		return &model.ImportParseError{
			Error: err.Error(),
		}, nil
	}

	// Convert to GraphQL model
	parsedConns := make([]*model.ParsedConnection, len(connections))
	for i, conn := range connections {
		parsedConns[i] = &model.ParsedConnection{
			Name:   conn.Name,
			Type:   conn.Type,
			Config: conn.Config,
		}
	}

	return &model.ImportParseSuccess{
		Connections: parsedConns,
	}, nil
}

// Execute is the resolver for the execute field.
func (r *importMutationResolver) Execute(ctx context.Context, obj *model.ImportMutation, input model.ImportExecuteInput) (*model.ImportExecuteResult, error) {
	if len(input.Connections) == 0 {
		return &model.ImportExecuteResult{
			Connections:  []*model.Connection{},
			CreatedCount: 0,
			UpdatedCount: 0,
		}, nil
	}

	var importedConns []*model.Connection
	var createdCount int
	var updatedCount int

	for _, connInput := range input.Connections {
		// Check if connection already exists
		existing, err := r.deps.ConnectionService.GetConnectionByName(ctx, connInput.Name)
		if err == nil && existing != nil {
			// Connection exists
			if input.Overwrite {
				// Update existing connection
				err := r.deps.ConnectionService.UpdateConnection(ctx, existing.ID, nil, &connInput.Type, connInput.Config)
				if err != nil {
					return nil, err
				}
				updatedCount++
				// Add to result (refetch to get updated info)
				updated, err := r.deps.ConnectionService.GetConnectionByName(ctx, connInput.Name)
				if err == nil && updated != nil {
					importedConns = append(importedConns, &model.Connection{
						ID:        updated.ID,
						Name:      updated.Name,
						Type:      updated.Type,
						CreatedAt: updated.CreatedAt,
						UpdatedAt: updated.UpdatedAt,
					})
				}
			}
			// If overwrite is false, skip existing connection
			continue
		}

		// Create new connection
		conn, err := r.deps.ConnectionService.CreateConnection(ctx, connInput.Name, connInput.Type, connInput.Config)
		if err != nil {
			return nil, err
		}

		createdCount++

		// Convert ent.Connection to model.Connection (config will be resolved by Connection.Config resolver)
		importedConns = append(importedConns, &model.Connection{
			ID:        conn.ID,
			Name:      conn.Name,
			Type:      conn.Type,
			CreatedAt: conn.CreatedAt,
			UpdatedAt: conn.UpdatedAt,
		})
	}

	return &model.ImportExecuteResult{
		Connections:  importedConns,
		CreatedCount: createdCount,
		UpdatedCount: updatedCount,
	}, nil
}

// Import is the resolver for the import field.
func (r *mutationResolver) Import(ctx context.Context) (*model.ImportMutation, error) {
	return &model.ImportMutation{}, nil
}

// ImportMutation returns generated.ImportMutationResolver implementation.
func (r *Resolver) ImportMutation() generated.ImportMutationResolver {
	return &importMutationResolver{r}
}

type importMutationResolver struct{ *Resolver }
