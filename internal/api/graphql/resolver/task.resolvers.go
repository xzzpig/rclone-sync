package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/google/uuid"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/dataloader"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/generated"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/utils"
)

// Task is the resolver for the task field.
func (r *mutationResolver) Task(ctx context.Context) (*model.TaskMutation, error) {
	return &model.TaskMutation{}, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context) (*model.TaskQuery, error) {
	return &model.TaskQuery{}, nil
}

// Options is the resolver for the options field.
func (r *taskResolver) Options(ctx context.Context, obj *model.Task) (*model.TaskSyncOptions, error) {
	// Fetch task from database to get options via TaskService
	entTask, err := r.deps.TaskService.GetTask(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	if entTask.Options == nil {
		return nil, nil
	}

	// Convert options map to TaskSyncOptions
	options := &model.TaskSyncOptions{}
	if cr, ok := entTask.Options["conflict_resolution"].(string); ok {
		conflictRes := model.ConflictResolution(cr)
		if conflictRes.IsValid() {
			options.ConflictResolution = &conflictRes
		}
	}

	return options, nil
}

// Connection is the resolver for the connection field.
func (r *taskResolver) Connection(ctx context.Context, obj *model.Task) (*model.Connection, error) {
	// Use dataloader to batch load connection - ConnectionID is already available in model
	loaders := dataloader.For(ctx)
	entConn, err := loaders.ConnectionLoader.Load(ctx, obj.ConnectionID)
	if err != nil {
		return nil, err
	}

	return entConnectionToModel(entConn), nil
}

// Jobs is the resolver for the jobs field.
func (r *taskResolver) Jobs(ctx context.Context, obj *model.Task, pagination *model.PaginationInput) (*model.JobConnection, error) {
	// Default pagination values
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil {
			offset = *pagination.Offset
		}
	}

	// Use TaskService to list jobs for this task
	entJobs, totalCount, err := r.deps.TaskService.ListJobsByTaskPaginated(ctx, obj.ID, limit, offset)
	if err != nil {
		return nil, err
	}

	// Convert ent jobs to model jobs
	items := make([]*model.Job, len(entJobs))
	for i, j := range entJobs {
		items[i] = entJobToModel(j)
	}

	// Build page info
	hasNextPage := offset+len(items) < totalCount
	hasPreviousPage := offset > 0

	return &model.JobConnection{
		Items:      items,
		TotalCount: totalCount,
		PageInfo: &model.OffsetPageInfo{
			Limit:           limit,
			Offset:          offset,
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
		},
	}, nil
}

// LatestJob is the resolver for the latestJob field.
func (r *taskResolver) LatestJob(ctx context.Context, obj *model.Task) (*model.Job, error) {
	entJob, err := r.deps.JobService.GetLastJobByTaskID(ctx, obj.ID)
	if err != nil {
		// If no job found, return nil (not an error)
		return nil, nil
	}
	return entJobToModel(entJob), nil
}

// Create is the resolver for the create field.
func (r *taskMutationResolver) Create(ctx context.Context, obj *model.TaskMutation, input model.CreateTaskInput) (*model.Task, error) {
	// Validate cron schedule if provided
	schedule := ""
	if input.Schedule != nil {
		schedule = *input.Schedule
		if err := utils.ValidateCronSchedule(schedule); err != nil {
			return nil, err
		}
	}

	// Build options map
	var options map[string]interface{}
	if input.Options != nil && input.Options.ConflictResolution != nil {
		options = map[string]interface{}{
			"conflict_resolution": string(*input.Options.ConflictResolution),
		}
	}

	// Default realtime to false if not provided
	realtime := false
	if input.Realtime != nil {
		realtime = *input.Realtime
	}

	// Create task
	entTask, err := r.deps.TaskService.CreateTask(
		ctx,
		input.Name,
		input.SourcePath,
		input.ConnectionID,
		input.RemotePath,
		string(input.Direction),
		schedule,
		realtime,
		options,
	)
	if err != nil {
		return nil, err
	}

	// If realtime sync is enabled, add to watcher
	if realtime && r.deps.Watcher != nil {
		if err := r.deps.Watcher.AddTask(entTask); err != nil {
			// Log the error but don't fail the request
			// The task was created successfully, watcher can be added later
		}
	}

	// If schedule is set, add to scheduler
	if schedule != "" && r.deps.Scheduler != nil {
		if err := r.deps.Scheduler.AddTask(entTask); err != nil {
			// Log but don't fail
		}
	}

	return entTaskToModel(entTask), nil
}

// Update is the resolver for the update field.
func (r *taskMutationResolver) Update(ctx context.Context, obj *model.TaskMutation, id uuid.UUID, input model.UpdateTaskInput) (*model.Task, error) {
	// Get existing task
	existingTask, err := r.deps.TaskService.GetTask(ctx, id)
	if err != nil {
		return nil, err
	}

	// Use existing values if not provided in update
	name := existingTask.Name
	if input.Name != nil {
		name = *input.Name
	}

	sourcePath := existingTask.SourcePath
	if input.SourcePath != nil {
		sourcePath = *input.SourcePath
	}

	connectionID := existingTask.ConnectionID
	if input.ConnectionID != nil {
		connectionID = *input.ConnectionID
	}

	remotePath := existingTask.RemotePath
	if input.RemotePath != nil {
		remotePath = *input.RemotePath
	}

	direction := string(existingTask.Direction)
	if input.Direction != nil {
		direction = string(*input.Direction)
	}

	schedule := existingTask.Schedule
	if input.Schedule != nil {
		schedule = *input.Schedule
		if err := utils.ValidateCronSchedule(schedule); err != nil {
			return nil, err
		}
	}

	realtime := existingTask.Realtime
	if input.Realtime != nil {
		realtime = *input.Realtime
	}

	options := existingTask.Options
	if input.Options != nil && input.Options.ConflictResolution != nil {
		options = map[string]interface{}{
			"conflict_resolution": string(*input.Options.ConflictResolution),
		}
	}

	// Update task
	updatedTask, err := r.deps.TaskService.UpdateTask(
		ctx,
		id,
		name,
		sourcePath,
		connectionID,
		remotePath,
		direction,
		schedule,
		realtime,
		options,
	)
	if err != nil {
		return nil, err
	}

	// Handle watcher updates based on realtime status changes
	if r.deps.Watcher != nil {
		if existingTask.Realtime != realtime {
			if realtime {
				// Realtime was enabled, add to watcher
				_ = r.deps.Watcher.AddTask(updatedTask)
			} else {
				// Realtime was disabled, remove from watcher
				_ = r.deps.Watcher.RemoveTask(updatedTask)
			}
		} else if realtime && existingTask.SourcePath != updatedTask.SourcePath {
			// Realtime is still enabled but source path changed, update watcher
			_ = r.deps.Watcher.RemoveTask(existingTask)
			_ = r.deps.Watcher.AddTask(updatedTask)
		}
	}

	// Handle scheduler updates based on schedule changes
	if r.deps.Scheduler != nil {
		if existingTask.Schedule != schedule {
			if schedule != "" {
				// Schedule was added/updated
				_ = r.deps.Scheduler.AddTask(updatedTask)
			} else {
				// Schedule was removed
				_ = r.deps.Scheduler.RemoveTask(updatedTask)
			}
		}
	}

	return entTaskToModel(updatedTask), nil
}

// Delete is the resolver for the delete field.
func (r *taskMutationResolver) Delete(ctx context.Context, obj *model.TaskMutation, id uuid.UUID) (*model.Task, error) {
	// Get task before deleting
	taskToDelete, err := r.deps.TaskService.GetTask(ctx, id)
	if err != nil {
		return nil, err
	}

	// If realtime is enabled, remove from watcher first
	if taskToDelete.Realtime && r.deps.Watcher != nil {
		_ = r.deps.Watcher.RemoveTask(taskToDelete)
	}

	// If schedule is set, remove from scheduler
	if taskToDelete.Schedule != "" && r.deps.Scheduler != nil {
		_ = r.deps.Scheduler.RemoveTask(taskToDelete)
	}

	// Delete the task
	if err := r.deps.TaskService.DeleteTask(ctx, id); err != nil {
		return nil, err
	}

	return entTaskToModel(taskToDelete), nil
}

// Run is the resolver for the run field.
func (r *taskMutationResolver) Run(ctx context.Context, obj *model.TaskMutation, taskID uuid.UUID) (*model.Job, error) {
	// Get task with connection
	entTask, err := r.deps.TaskService.GetTaskWithConnection(ctx, taskID)
	if err != nil {
		return nil, err
	}

	// Start the task via runner
	if err := r.deps.Runner.StartTask(entTask, model.JobTriggerManual); err != nil {
		return nil, err
	}

	// Get the latest job created for this task
	entJob, err := r.deps.JobService.GetLastJobByTaskID(ctx, taskID)
	if err != nil {
		return nil, err
	}

	return entJobToModel(entJob), nil
}

// List is the resolver for the list field.
func (r *taskQueryResolver) List(ctx context.Context, obj *model.TaskQuery, pagination *model.PaginationInput) (*model.TaskConnection, error) {
	// Default pagination values
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil {
			offset = *pagination.Offset
		}
	}

	// Use TaskService to list tasks
	entTasks, totalCount, err := r.deps.TaskService.ListTasksPaginated(ctx, limit, offset)
	if err != nil {
		return nil, err
	}

	// Convert ent tasks to model tasks
	items := make([]*model.Task, len(entTasks))
	for i, t := range entTasks {
		items[i] = entTaskToModel(t)
	}

	// Build page info
	hasNextPage := offset+len(items) < totalCount
	hasPreviousPage := offset > 0

	return &model.TaskConnection{
		Items:      items,
		TotalCount: totalCount,
		PageInfo: &model.OffsetPageInfo{
			Limit:           limit,
			Offset:          offset,
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
		},
	}, nil
}

// Get is the resolver for the get field.
func (r *taskQueryResolver) Get(ctx context.Context, obj *model.TaskQuery, id uuid.UUID) (*model.Task, error) {
	entTask, err := r.deps.TaskService.GetTask(ctx, id)
	if err != nil {
		// Return nil for not found, this is valid for GraphQL
		return nil, nil
	}
	return entTaskToModel(entTask), nil
}

// Task returns generated.TaskResolver implementation.
func (r *Resolver) Task() generated.TaskResolver { return &taskResolver{r} }

// TaskMutation returns generated.TaskMutationResolver implementation.
func (r *Resolver) TaskMutation() generated.TaskMutationResolver { return &taskMutationResolver{r} }

// TaskQuery returns generated.TaskQueryResolver implementation.
func (r *Resolver) TaskQuery() generated.TaskQueryResolver { return &taskQueryResolver{r} }

type taskResolver struct{ *Resolver }
type taskMutationResolver struct{ *Resolver }
type taskQueryResolver struct{ *Resolver }
