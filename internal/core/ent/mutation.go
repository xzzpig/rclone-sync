// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/xzzpig/rclone-sync/internal/api/graphql/model"
	"github.com/xzzpig/rclone-sync/internal/core/ent/connection"
	"github.com/xzzpig/rclone-sync/internal/core/ent/job"
	"github.com/xzzpig/rclone-sync/internal/core/ent/joblog"
	"github.com/xzzpig/rclone-sync/internal/core/ent/predicate"
	"github.com/xzzpig/rclone-sync/internal/core/ent/task"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConnection = "Connection"
	TypeJob        = "Job"
	TypeJobLog     = "JobLog"
	TypeTask       = "Task"
)

// ConnectionMutation represents an operation that mutates the Connection nodes in the graph.
type ConnectionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	_type            *string
	encrypted_config *[]byte
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	tasks            map[uuid.UUID]struct{}
	removedtasks     map[uuid.UUID]struct{}
	clearedtasks     bool
	done             bool
	oldValue         func(context.Context) (*Connection, error)
	predicates       []predicate.Connection
}

var _ ent.Mutation = (*ConnectionMutation)(nil)

// connectionOption allows management of the mutation configuration using functional options.
type connectionOption func(*ConnectionMutation)

// newConnectionMutation creates new mutation for the Connection entity.
func newConnectionMutation(c config, op Op, opts ...connectionOption) *ConnectionMutation {
	m := &ConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionID sets the ID field of the mutation.
func withConnectionID(id uuid.UUID) connectionOption {
	return func(m *ConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Connection
		)
		m.oldValue = func(ctx context.Context) (*Connection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnection sets the old Connection of the mutation.
func withConnection(node *Connection) connectionOption {
	return func(m *ConnectionMutation) {
		m.oldValue = func(context.Context) (*Connection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connection entities.
func (m *ConnectionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectionMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ConnectionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ConnectionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ConnectionMutation) ResetType() {
	m._type = nil
}

// SetEncryptedConfig sets the "encrypted_config" field.
func (m *ConnectionMutation) SetEncryptedConfig(b []byte) {
	m.encrypted_config = &b
}

// EncryptedConfig returns the value of the "encrypted_config" field in the mutation.
func (m *ConnectionMutation) EncryptedConfig() (r []byte, exists bool) {
	v := m.encrypted_config
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedConfig returns the old "encrypted_config" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldEncryptedConfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedConfig: %w", err)
	}
	return oldValue.EncryptedConfig, nil
}

// ResetEncryptedConfig resets all changes to the "encrypted_config" field.
func (m *ConnectionMutation) ResetEncryptedConfig() {
	m.encrypted_config = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ConnectionMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ConnectionMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ConnectionMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ConnectionMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ConnectionMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ConnectionMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ConnectionMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the ConnectionMutation builder.
func (m *ConnectionMutation) Where(ps ...predicate.Connection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connection).
func (m *ConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, connection.FieldName)
	}
	if m._type != nil {
		fields = append(fields, connection.FieldType)
	}
	if m.encrypted_config != nil {
		fields = append(fields, connection.FieldEncryptedConfig)
	}
	if m.created_at != nil {
		fields = append(fields, connection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, connection.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connection.FieldName:
		return m.Name()
	case connection.FieldType:
		return m.GetType()
	case connection.FieldEncryptedConfig:
		return m.EncryptedConfig()
	case connection.FieldCreatedAt:
		return m.CreatedAt()
	case connection.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connection.FieldName:
		return m.OldName(ctx)
	case connection.FieldType:
		return m.OldType(ctx)
	case connection.FieldEncryptedConfig:
		return m.OldEncryptedConfig(ctx)
	case connection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case connection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Connection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connection.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case connection.FieldEncryptedConfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedConfig(v)
		return nil
	case connection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case connection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Connection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionMutation) ResetField(name string) error {
	switch name {
	case connection.FieldName:
		m.ResetName()
		return nil
	case connection.FieldType:
		m.ResetType()
		return nil
	case connection.FieldEncryptedConfig:
		m.ResetEncryptedConfig()
		return nil
	case connection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case connection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tasks != nil {
		edges = append(edges, connection.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtasks != nil {
		edges = append(edges, connection.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtasks {
		edges = append(edges, connection.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case connection.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Connection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionMutation) ResetEdge(name string) error {
	switch name {
	case connection.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Connection edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	status               *model.JobStatus
	trigger              *model.JobTrigger
	start_time           *time.Time
	end_time             *time.Time
	files_transferred    *int
	addfiles_transferred *int
	bytes_transferred    *int64
	addbytes_transferred *int64
	errors               *string
	clearedFields        map[string]struct{}
	task                 *uuid.UUID
	clearedtask          bool
	logs                 map[int]struct{}
	removedlogs          map[int]struct{}
	clearedlogs          bool
	done                 bool
	oldValue             func(context.Context) (*Job, error)
	predicates           []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id uuid.UUID) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *JobMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *JobMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *JobMutation) ResetTaskID() {
	m.task = nil
}

// SetStatus sets the "status" field.
func (m *JobMutation) SetStatus(ms model.JobStatus) {
	m.status = &ms
}

// Status returns the value of the "status" field in the mutation.
func (m *JobMutation) Status() (r model.JobStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldStatus(ctx context.Context) (v model.JobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobMutation) ResetStatus() {
	m.status = nil
}

// SetTrigger sets the "trigger" field.
func (m *JobMutation) SetTrigger(mt model.JobTrigger) {
	m.trigger = &mt
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *JobMutation) Trigger() (r model.JobTrigger, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTrigger(ctx context.Context) (v model.JobTrigger, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *JobMutation) ResetTrigger() {
	m.trigger = nil
}

// SetStartTime sets the "start_time" field.
func (m *JobMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *JobMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *JobMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *JobMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *JobMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *JobMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[job.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *JobMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[job.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *JobMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, job.FieldEndTime)
}

// SetFilesTransferred sets the "files_transferred" field.
func (m *JobMutation) SetFilesTransferred(i int) {
	m.files_transferred = &i
	m.addfiles_transferred = nil
}

// FilesTransferred returns the value of the "files_transferred" field in the mutation.
func (m *JobMutation) FilesTransferred() (r int, exists bool) {
	v := m.files_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesTransferred returns the old "files_transferred" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldFilesTransferred(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesTransferred: %w", err)
	}
	return oldValue.FilesTransferred, nil
}

// AddFilesTransferred adds i to the "files_transferred" field.
func (m *JobMutation) AddFilesTransferred(i int) {
	if m.addfiles_transferred != nil {
		*m.addfiles_transferred += i
	} else {
		m.addfiles_transferred = &i
	}
}

// AddedFilesTransferred returns the value that was added to the "files_transferred" field in this mutation.
func (m *JobMutation) AddedFilesTransferred() (r int, exists bool) {
	v := m.addfiles_transferred
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesTransferred resets all changes to the "files_transferred" field.
func (m *JobMutation) ResetFilesTransferred() {
	m.files_transferred = nil
	m.addfiles_transferred = nil
}

// SetBytesTransferred sets the "bytes_transferred" field.
func (m *JobMutation) SetBytesTransferred(i int64) {
	m.bytes_transferred = &i
	m.addbytes_transferred = nil
}

// BytesTransferred returns the value of the "bytes_transferred" field in the mutation.
func (m *JobMutation) BytesTransferred() (r int64, exists bool) {
	v := m.bytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldBytesTransferred returns the old "bytes_transferred" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldBytesTransferred(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBytesTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBytesTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBytesTransferred: %w", err)
	}
	return oldValue.BytesTransferred, nil
}

// AddBytesTransferred adds i to the "bytes_transferred" field.
func (m *JobMutation) AddBytesTransferred(i int64) {
	if m.addbytes_transferred != nil {
		*m.addbytes_transferred += i
	} else {
		m.addbytes_transferred = &i
	}
}

// AddedBytesTransferred returns the value that was added to the "bytes_transferred" field in this mutation.
func (m *JobMutation) AddedBytesTransferred() (r int64, exists bool) {
	v := m.addbytes_transferred
	if v == nil {
		return
	}
	return *v, true
}

// ResetBytesTransferred resets all changes to the "bytes_transferred" field.
func (m *JobMutation) ResetBytesTransferred() {
	m.bytes_transferred = nil
	m.addbytes_transferred = nil
}

// SetErrors sets the "errors" field.
func (m *JobMutation) SetErrors(s string) {
	m.errors = &s
}

// Errors returns the value of the "errors" field in the mutation.
func (m *JobMutation) Errors() (r string, exists bool) {
	v := m.errors
	if v == nil {
		return
	}
	return *v, true
}

// OldErrors returns the old "errors" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldErrors(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrors: %w", err)
	}
	return oldValue.Errors, nil
}

// ClearErrors clears the value of the "errors" field.
func (m *JobMutation) ClearErrors() {
	m.errors = nil
	m.clearedFields[job.FieldErrors] = struct{}{}
}

// ErrorsCleared returns if the "errors" field was cleared in this mutation.
func (m *JobMutation) ErrorsCleared() bool {
	_, ok := m.clearedFields[job.FieldErrors]
	return ok
}

// ResetErrors resets all changes to the "errors" field.
func (m *JobMutation) ResetErrors() {
	m.errors = nil
	delete(m.clearedFields, job.FieldErrors)
}

// ClearTask clears the "task" edge to the Task entity.
func (m *JobMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[job.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *JobMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *JobMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *JobMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// AddLogIDs adds the "logs" edge to the JobLog entity by ids.
func (m *JobMutation) AddLogIDs(ids ...int) {
	if m.logs == nil {
		m.logs = make(map[int]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the JobLog entity.
func (m *JobMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the JobLog entity was cleared.
func (m *JobMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the JobLog entity by IDs.
func (m *JobMutation) RemoveLogIDs(ids ...int) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the JobLog entity.
func (m *JobMutation) RemovedLogsIDs() (ids []int) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *JobMutation) LogsIDs() (ids []int) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *JobMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.task != nil {
		fields = append(fields, job.FieldTaskID)
	}
	if m.status != nil {
		fields = append(fields, job.FieldStatus)
	}
	if m.trigger != nil {
		fields = append(fields, job.FieldTrigger)
	}
	if m.start_time != nil {
		fields = append(fields, job.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, job.FieldEndTime)
	}
	if m.files_transferred != nil {
		fields = append(fields, job.FieldFilesTransferred)
	}
	if m.bytes_transferred != nil {
		fields = append(fields, job.FieldBytesTransferred)
	}
	if m.errors != nil {
		fields = append(fields, job.FieldErrors)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldTaskID:
		return m.TaskID()
	case job.FieldStatus:
		return m.Status()
	case job.FieldTrigger:
		return m.Trigger()
	case job.FieldStartTime:
		return m.StartTime()
	case job.FieldEndTime:
		return m.EndTime()
	case job.FieldFilesTransferred:
		return m.FilesTransferred()
	case job.FieldBytesTransferred:
		return m.BytesTransferred()
	case job.FieldErrors:
		return m.Errors()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldTaskID:
		return m.OldTaskID(ctx)
	case job.FieldStatus:
		return m.OldStatus(ctx)
	case job.FieldTrigger:
		return m.OldTrigger(ctx)
	case job.FieldStartTime:
		return m.OldStartTime(ctx)
	case job.FieldEndTime:
		return m.OldEndTime(ctx)
	case job.FieldFilesTransferred:
		return m.OldFilesTransferred(ctx)
	case job.FieldBytesTransferred:
		return m.OldBytesTransferred(ctx)
	case job.FieldErrors:
		return m.OldErrors(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case job.FieldStatus:
		v, ok := value.(model.JobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case job.FieldTrigger:
		v, ok := value.(model.JobTrigger)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	case job.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case job.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case job.FieldFilesTransferred:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesTransferred(v)
		return nil
	case job.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBytesTransferred(v)
		return nil
	case job.FieldErrors:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrors(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addfiles_transferred != nil {
		fields = append(fields, job.FieldFilesTransferred)
	}
	if m.addbytes_transferred != nil {
		fields = append(fields, job.FieldBytesTransferred)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldFilesTransferred:
		return m.AddedFilesTransferred()
	case job.FieldBytesTransferred:
		return m.AddedBytesTransferred()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldFilesTransferred:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesTransferred(v)
		return nil
	case job.FieldBytesTransferred:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBytesTransferred(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldEndTime) {
		fields = append(fields, job.FieldEndTime)
	}
	if m.FieldCleared(job.FieldErrors) {
		fields = append(fields, job.FieldErrors)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldEndTime:
		m.ClearEndTime()
		return nil
	case job.FieldErrors:
		m.ClearErrors()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldTaskID:
		m.ResetTaskID()
		return nil
	case job.FieldStatus:
		m.ResetStatus()
		return nil
	case job.FieldTrigger:
		m.ResetTrigger()
		return nil
	case job.FieldStartTime:
		m.ResetStartTime()
		return nil
	case job.FieldEndTime:
		m.ResetEndTime()
		return nil
	case job.FieldFilesTransferred:
		m.ResetFilesTransferred()
		return nil
	case job.FieldBytesTransferred:
		m.ResetBytesTransferred()
		return nil
	case job.FieldErrors:
		m.ResetErrors()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, job.EdgeTask)
	}
	if m.logs != nil {
		edges = append(edges, job.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlogs != nil {
		edges = append(edges, job.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, job.EdgeTask)
	}
	if m.clearedlogs {
		edges = append(edges, job.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeTask:
		return m.clearedtask
	case job.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeTask:
		m.ResetTask()
		return nil
	case job.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobLogMutation represents an operation that mutates the JobLog nodes in the graph.
type JobLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	level         *model.LogLevel
	time          *time.Time
	_path         *string
	what          *model.LogAction
	size          *int64
	addsize       *int64
	clearedFields map[string]struct{}
	job           *uuid.UUID
	clearedjob    bool
	done          bool
	oldValue      func(context.Context) (*JobLog, error)
	predicates    []predicate.JobLog
}

var _ ent.Mutation = (*JobLogMutation)(nil)

// joblogOption allows management of the mutation configuration using functional options.
type joblogOption func(*JobLogMutation)

// newJobLogMutation creates new mutation for the JobLog entity.
func newJobLogMutation(c config, op Op, opts ...joblogOption) *JobLogMutation {
	m := &JobLogMutation{
		config:        c,
		op:            op,
		typ:           TypeJobLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobLogID sets the ID field of the mutation.
func withJobLogID(id int) joblogOption {
	return func(m *JobLogMutation) {
		var (
			err   error
			once  sync.Once
			value *JobLog
		)
		m.oldValue = func(ctx context.Context) (*JobLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobLog sets the old JobLog of the mutation.
func withJobLog(node *JobLog) joblogOption {
	return func(m *JobLogMutation) {
		m.oldValue = func(context.Context) (*JobLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *JobLogMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobLogMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobLogMutation) ResetJobID() {
	m.job = nil
}

// SetLevel sets the "level" field.
func (m *JobLogMutation) SetLevel(ml model.LogLevel) {
	m.level = &ml
}

// Level returns the value of the "level" field in the mutation.
func (m *JobLogMutation) Level() (r model.LogLevel, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldLevel(ctx context.Context) (v model.LogLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *JobLogMutation) ResetLevel() {
	m.level = nil
}

// SetTime sets the "time" field.
func (m *JobLogMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *JobLogMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *JobLogMutation) ResetTime() {
	m.time = nil
}

// SetPath sets the "path" field.
func (m *JobLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *JobLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *JobLogMutation) ClearPath() {
	m._path = nil
	m.clearedFields[joblog.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *JobLogMutation) PathCleared() bool {
	_, ok := m.clearedFields[joblog.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *JobLogMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, joblog.FieldPath)
}

// SetWhat sets the "what" field.
func (m *JobLogMutation) SetWhat(ma model.LogAction) {
	m.what = &ma
}

// What returns the value of the "what" field in the mutation.
func (m *JobLogMutation) What() (r model.LogAction, exists bool) {
	v := m.what
	if v == nil {
		return
	}
	return *v, true
}

// OldWhat returns the old "what" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldWhat(ctx context.Context) (v model.LogAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhat: %w", err)
	}
	return oldValue.What, nil
}

// ResetWhat resets all changes to the "what" field.
func (m *JobLogMutation) ResetWhat() {
	m.what = nil
}

// SetSize sets the "size" field.
func (m *JobLogMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *JobLogMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *JobLogMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *JobLogMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *JobLogMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[joblog.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *JobLogMutation) SizeCleared() bool {
	_, ok := m.clearedFields[joblog.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *JobLogMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, joblog.FieldSize)
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobLogMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[joblog.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobLogMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobLogMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobLogMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobLogMutation builder.
func (m *JobLogMutation) Where(ps ...predicate.JobLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobLog).
func (m *JobLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.job != nil {
		fields = append(fields, joblog.FieldJobID)
	}
	if m.level != nil {
		fields = append(fields, joblog.FieldLevel)
	}
	if m.time != nil {
		fields = append(fields, joblog.FieldTime)
	}
	if m._path != nil {
		fields = append(fields, joblog.FieldPath)
	}
	if m.what != nil {
		fields = append(fields, joblog.FieldWhat)
	}
	if m.size != nil {
		fields = append(fields, joblog.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joblog.FieldJobID:
		return m.JobID()
	case joblog.FieldLevel:
		return m.Level()
	case joblog.FieldTime:
		return m.Time()
	case joblog.FieldPath:
		return m.Path()
	case joblog.FieldWhat:
		return m.What()
	case joblog.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joblog.FieldJobID:
		return m.OldJobID(ctx)
	case joblog.FieldLevel:
		return m.OldLevel(ctx)
	case joblog.FieldTime:
		return m.OldTime(ctx)
	case joblog.FieldPath:
		return m.OldPath(ctx)
	case joblog.FieldWhat:
		return m.OldWhat(ctx)
	case joblog.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown JobLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joblog.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case joblog.FieldLevel:
		v, ok := value.(model.LogLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case joblog.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case joblog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case joblog.FieldWhat:
		v, ok := value.(model.LogAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhat(v)
		return nil
	case joblog.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown JobLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobLogMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, joblog.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case joblog.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case joblog.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown JobLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joblog.FieldPath) {
		fields = append(fields, joblog.FieldPath)
	}
	if m.FieldCleared(joblog.FieldSize) {
		fields = append(fields, joblog.FieldSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobLogMutation) ClearField(name string) error {
	switch name {
	case joblog.FieldPath:
		m.ClearPath()
		return nil
	case joblog.FieldSize:
		m.ClearSize()
		return nil
	}
	return fmt.Errorf("unknown JobLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobLogMutation) ResetField(name string) error {
	switch name {
	case joblog.FieldJobID:
		m.ResetJobID()
		return nil
	case joblog.FieldLevel:
		m.ResetLevel()
		return nil
	case joblog.FieldTime:
		m.ResetTime()
		return nil
	case joblog.FieldPath:
		m.ResetPath()
		return nil
	case joblog.FieldWhat:
		m.ResetWhat()
		return nil
	case joblog.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown JobLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, joblog.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joblog.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, joblog.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobLogMutation) EdgeCleared(name string) bool {
	switch name {
	case joblog.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobLogMutation) ClearEdge(name string) error {
	switch name {
	case joblog.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobLogMutation) ResetEdge(name string) error {
	switch name {
	case joblog.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobLog edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	source_path       *string
	remote_path       *string
	direction         *model.SyncDirection
	schedule          *string
	realtime          *bool
	options           *map[string]interface{}
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	jobs              map[uuid.UUID]struct{}
	removedjobs       map[uuid.UUID]struct{}
	clearedjobs       bool
	connection        *uuid.UUID
	clearedconnection bool
	done              bool
	oldValue          func(context.Context) (*Task, error)
	predicates        []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetSourcePath sets the "source_path" field.
func (m *TaskMutation) SetSourcePath(s string) {
	m.source_path = &s
}

// SourcePath returns the value of the "source_path" field in the mutation.
func (m *TaskMutation) SourcePath() (r string, exists bool) {
	v := m.source_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSourcePath returns the old "source_path" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSourcePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourcePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourcePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourcePath: %w", err)
	}
	return oldValue.SourcePath, nil
}

// ResetSourcePath resets all changes to the "source_path" field.
func (m *TaskMutation) ResetSourcePath() {
	m.source_path = nil
}

// SetConnectionID sets the "connection_id" field.
func (m *TaskMutation) SetConnectionID(u uuid.UUID) {
	m.connection = &u
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *TaskMutation) ConnectionID() (r uuid.UUID, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldConnectionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ClearConnectionID clears the value of the "connection_id" field.
func (m *TaskMutation) ClearConnectionID() {
	m.connection = nil
	m.clearedFields[task.FieldConnectionID] = struct{}{}
}

// ConnectionIDCleared returns if the "connection_id" field was cleared in this mutation.
func (m *TaskMutation) ConnectionIDCleared() bool {
	_, ok := m.clearedFields[task.FieldConnectionID]
	return ok
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *TaskMutation) ResetConnectionID() {
	m.connection = nil
	delete(m.clearedFields, task.FieldConnectionID)
}

// SetRemotePath sets the "remote_path" field.
func (m *TaskMutation) SetRemotePath(s string) {
	m.remote_path = &s
}

// RemotePath returns the value of the "remote_path" field in the mutation.
func (m *TaskMutation) RemotePath() (r string, exists bool) {
	v := m.remote_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRemotePath returns the old "remote_path" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRemotePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemotePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemotePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemotePath: %w", err)
	}
	return oldValue.RemotePath, nil
}

// ResetRemotePath resets all changes to the "remote_path" field.
func (m *TaskMutation) ResetRemotePath() {
	m.remote_path = nil
}

// SetDirection sets the "direction" field.
func (m *TaskMutation) SetDirection(md model.SyncDirection) {
	m.direction = &md
}

// Direction returns the value of the "direction" field in the mutation.
func (m *TaskMutation) Direction() (r model.SyncDirection, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDirection(ctx context.Context) (v model.SyncDirection, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// ResetDirection resets all changes to the "direction" field.
func (m *TaskMutation) ResetDirection() {
	m.direction = nil
}

// SetSchedule sets the "schedule" field.
func (m *TaskMutation) SetSchedule(s string) {
	m.schedule = &s
}

// Schedule returns the value of the "schedule" field in the mutation.
func (m *TaskMutation) Schedule() (r string, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedule returns the old "schedule" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedule: %w", err)
	}
	return oldValue.Schedule, nil
}

// ClearSchedule clears the value of the "schedule" field.
func (m *TaskMutation) ClearSchedule() {
	m.schedule = nil
	m.clearedFields[task.FieldSchedule] = struct{}{}
}

// ScheduleCleared returns if the "schedule" field was cleared in this mutation.
func (m *TaskMutation) ScheduleCleared() bool {
	_, ok := m.clearedFields[task.FieldSchedule]
	return ok
}

// ResetSchedule resets all changes to the "schedule" field.
func (m *TaskMutation) ResetSchedule() {
	m.schedule = nil
	delete(m.clearedFields, task.FieldSchedule)
}

// SetRealtime sets the "realtime" field.
func (m *TaskMutation) SetRealtime(b bool) {
	m.realtime = &b
}

// Realtime returns the value of the "realtime" field in the mutation.
func (m *TaskMutation) Realtime() (r bool, exists bool) {
	v := m.realtime
	if v == nil {
		return
	}
	return *v, true
}

// OldRealtime returns the old "realtime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRealtime(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealtime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealtime: %w", err)
	}
	return oldValue.Realtime, nil
}

// ResetRealtime resets all changes to the "realtime" field.
func (m *TaskMutation) ResetRealtime() {
	m.realtime = nil
}

// SetOptions sets the "options" field.
func (m *TaskMutation) SetOptions(value map[string]interface{}) {
	m.options = &value
}

// Options returns the value of the "options" field in the mutation.
func (m *TaskMutation) Options() (r map[string]interface{}, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOptions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ClearOptions clears the value of the "options" field.
func (m *TaskMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[task.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *TaskMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[task.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *TaskMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, task.FieldOptions)
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *TaskMutation) AddJobIDs(ids ...uuid.UUID) {
	if m.jobs == nil {
		m.jobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *TaskMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *TaskMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *TaskMutation) RemoveJobIDs(ids ...uuid.UUID) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *TaskMutation) RemovedJobsIDs() (ids []uuid.UUID) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *TaskMutation) JobsIDs() (ids []uuid.UUID) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *TaskMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *TaskMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[task.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *TaskMutation) ConnectionCleared() bool {
	return m.ConnectionIDCleared() || m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ConnectionIDs() (ids []uuid.UUID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *TaskMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.source_path != nil {
		fields = append(fields, task.FieldSourcePath)
	}
	if m.connection != nil {
		fields = append(fields, task.FieldConnectionID)
	}
	if m.remote_path != nil {
		fields = append(fields, task.FieldRemotePath)
	}
	if m.direction != nil {
		fields = append(fields, task.FieldDirection)
	}
	if m.schedule != nil {
		fields = append(fields, task.FieldSchedule)
	}
	if m.realtime != nil {
		fields = append(fields, task.FieldRealtime)
	}
	if m.options != nil {
		fields = append(fields, task.FieldOptions)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldSourcePath:
		return m.SourcePath()
	case task.FieldConnectionID:
		return m.ConnectionID()
	case task.FieldRemotePath:
		return m.RemotePath()
	case task.FieldDirection:
		return m.Direction()
	case task.FieldSchedule:
		return m.Schedule()
	case task.FieldRealtime:
		return m.Realtime()
	case task.FieldOptions:
		return m.Options()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldSourcePath:
		return m.OldSourcePath(ctx)
	case task.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case task.FieldRemotePath:
		return m.OldRemotePath(ctx)
	case task.FieldDirection:
		return m.OldDirection(ctx)
	case task.FieldSchedule:
		return m.OldSchedule(ctx)
	case task.FieldRealtime:
		return m.OldRealtime(ctx)
	case task.FieldOptions:
		return m.OldOptions(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldSourcePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourcePath(v)
		return nil
	case task.FieldConnectionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case task.FieldRemotePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemotePath(v)
		return nil
	case task.FieldDirection:
		v, ok := value.(model.SyncDirection)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case task.FieldSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedule(v)
		return nil
	case task.FieldRealtime:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealtime(v)
		return nil
	case task.FieldOptions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldConnectionID) {
		fields = append(fields, task.FieldConnectionID)
	}
	if m.FieldCleared(task.FieldSchedule) {
		fields = append(fields, task.FieldSchedule)
	}
	if m.FieldCleared(task.FieldOptions) {
		fields = append(fields, task.FieldOptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldConnectionID:
		m.ClearConnectionID()
		return nil
	case task.FieldSchedule:
		m.ClearSchedule()
		return nil
	case task.FieldOptions:
		m.ClearOptions()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldSourcePath:
		m.ResetSourcePath()
		return nil
	case task.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case task.FieldRemotePath:
		m.ResetRemotePath()
		return nil
	case task.FieldDirection:
		m.ResetDirection()
		return nil
	case task.FieldSchedule:
		m.ResetSchedule()
		return nil
	case task.FieldRealtime:
		m.ResetRealtime()
		return nil
	case task.FieldOptions:
		m.ResetOptions()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.jobs != nil {
		edges = append(edges, task.EdgeJobs)
	}
	if m.connection != nil {
		edges = append(edges, task.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjobs != nil {
		edges = append(edges, task.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjobs {
		edges = append(edges, task.EdgeJobs)
	}
	if m.clearedconnection {
		edges = append(edges, task.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeJobs:
		return m.clearedjobs
	case task.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeJobs:
		m.ResetJobs()
		return nil
	case task.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
