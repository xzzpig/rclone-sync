const fs = require('fs');
const path = require('path');

// 配置路径
const ROOT_DIR = path.resolve(__dirname, '..');
const SCHEMA_DIR = path.join(ROOT_DIR, 'internal/api/graphql/schema');
const OUTPUT_FILE = path.join(ROOT_DIR, 'web/src/api/graphql/schema.graphql');

console.log(`Merging schemas from ${SCHEMA_DIR}...`);

try {
    // 确保输出目录存在
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    // 读取所有 .graphql 文件
    const files = fs.readdirSync(SCHEMA_DIR)
        .filter(file => file.endsWith('.graphql'))
        .sort((a, b) => {
            // 确保 schema.graphql 排在最前面，因为它包含基础类型定义
            if (a === 'schema.graphql') return -1;
            if (b === 'schema.graphql') return 1;
            return a.localeCompare(b);
        });

    let mergedContent = '# Auto-generated schema file. Do not edit manually.\n';
    mergedContent += `# Generated by scripts/merge-schema.js\n`;
    mergedContent += `# Date: ${new Date().toISOString()}

`;

    for (const file of files) {
        const filePath = path.join(SCHEMA_DIR, file);
        const content = fs.readFileSync(filePath, 'utf-8');
        mergedContent += `# Source: ${file}
`;
        mergedContent += content + '\n\n';
    }

    // 写入输出文件
    fs.writeFileSync(OUTPUT_FILE, mergedContent);
    console.log(`Successfully merged ${files.length} files to ${OUTPUT_FILE}`);

} catch (error) {
    console.error('Error merging schemas:', error);
    process.exit(1);
}
