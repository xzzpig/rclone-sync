# Data Model: Versioned Database Migration

**Feature**: 005-versioned-migration  
**Date**: 2025-12-19  
**Status**: Complete

## Overview

This feature primarily involves the storage and management of migration records, using the `schema_migrations` table automatically managed by golang-migrate. There is no need to define new entities in the ent schema.

## Entities

### 1. Migration Records (Schema Migrations) - Automatically managed by golang-migrate

golang-migrate automatically creates and manages the migration record table; there is no need to manually define an ent schema.

**Table Name**: `schema_migrations`

| Field | Type | Description |
|------|------|------|
| version | INTEGER PRIMARY KEY | Current migration version number (e.g., 1, 2, 3) |
| dirty | BOOLEAN | Whether it is in a dirty state (migration interrupted/failed) |

**Characteristics**:
- Only records the current version, not the history
- The `dirty` flag is used to detect interrupted migrations
- Simple table structure, easy for manual troubleshooting

**Status Description**:

| dirty | Meaning |
|-------|------|
| 0 (false) | Normal state, migration successfully completed |
| 1 (true) | Dirty state, the last migration was incomplete/failed |

---

## Migration File Structure

### Migration Directory

```
internal/core/db/
├── db.go                            # Database initialization
├── migrate.go                       # Migration execution logic
├── embed.go                         # Go embed declaration
├── errors.go                        # Migration error types
└── migrations/                      # Migration script directory (pure SQL files)
    ├── 000001_initial.up.sql        # Baseline migration (up)
    ├── 000001_initial.down.sql      # Baseline migration (down)
    ├── 000002_add_feature.up.sql    # Subsequent migration
    ├── 000002_add_feature.down.sql
    └── ...
```

### Migration File Naming Convention

Format: `{version}_{name}.up.sql` and `{version}_{name}.down.sql`

- **Version number**: 6 digits, e.g., `000001`, `000002`
- **Name**: English description separated by underscores
- **Suffix**: `.up.sql` upgrade script, `.down.sql` rollback script

### Baseline Migration File Content

The baseline migration contains the DDL generated by all current ent schemas:

**000001_initial.up.sql**:
```sql
-- Initial schema baseline for versioned migration

-- Create "connections" table
CREATE TABLE IF NOT EXISTS `connections` (
    `id` uuid NOT NULL PRIMARY KEY,
    `name` text NOT NULL,
    `type` text NOT NULL,
    `encrypted_config` blob NOT NULL,
    `created_at` datetime NOT NULL,
    `updated_at` datetime NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS `connection_name` ON `connections` (`name`);

-- Create "jobs" table
CREATE TABLE IF NOT EXISTS `jobs` (
    `id` uuid NOT NULL PRIMARY KEY,
    `name` text NOT NULL,
    `source` text NOT NULL,
    `destination` text NOT NULL,
    `sync_direction` text NOT NULL DEFAULT 'sync',
    `cron` text,
    `enabled` integer NOT NULL DEFAULT 1,
    `created_at` datetime NOT NULL,
    `updated_at` datetime NOT NULL
);

-- Create "job_logs" table
CREATE TABLE IF NOT EXISTS `job_logs` (
    `id` uuid NOT NULL PRIMARY KEY,
    `job_id` uuid NOT NULL,
    `status` text NOT NULL,
    `message` text,
    `started_at` datetime NOT NULL,
    `finished_at` datetime,
    FOREIGN KEY (`job_id`) REFERENCES `jobs` (`id`) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS `joblog_job_id` ON `job_logs` (`job_id`);
```

**000001_initial.down.sql**:
```sql
-- Rollback initial schema

DROP INDEX IF EXISTS `joblog_job_id`;
DROP TABLE IF EXISTS `job_logs`;
DROP TABLE IF EXISTS `jobs`;
DROP INDEX IF EXISTS `connection_name`;
DROP TABLE IF EXISTS `connections`;
```

---

## Related Go Types

### MigrationError

Migration error wrapper type:

```go
// internal/core/db/errors.go
package db

import (
    "github.com/xzzpig/rclone-sync/internal/i18n"
)

// MigrationError represents a migration execution error
type MigrationError struct {
    Version int    // The failed migration version
    Dirty   bool   // Whether it is in a dirty state
    Cause   error  // The original error
}

func (e *MigrationError) Error() string {
    return e.Cause.Error()
}

func (e *MigrationError) Unwrap() error {
    return e.Cause
}

// ToI18nError converts to an internationalized error
func (e *MigrationError) ToI18nError() *i18n.I18nError {
    if e.Dirty {
        return i18n.NewI18nError(i18n.MigrationDirtyDatabase, nil)
    }
    return i18n.NewI18nError(i18n.MigrationFailed, map[string]interface{}{
        "Error": e.Cause.Error(),
    })
}
```

---

## Validation Rules

### Migration File Validation

1. **File name format**: Must match `^\d{6}_\w+\.(up|down)\.sql`
2. **Version uniqueness**: Version numbers cannot be duplicated
3. **Exists in pairs**: Each version should have `.up.sql` and `.down.sql` (down can be an empty file)
4. **Sequential consistency**: Version numbers must increase consecutively

### Database Status Validation

At startup, golang-migrate checks the database status:

| Status | Condition | Action |
|------|------|------|
| New database | No schema_migrations table | ✅ Execute all migrations normally |
| Versioned | schema_migrations exists, dirty=0 | ✅ Execute pending migrations |
| Dirty state | schema_migrations exists, dirty=1 | ❌ Error, manual intervention required |
| Incompatible | Business tables exist, no schema_migrations | ❌ CREATE TABLE fails |

---

## Relationship Diagram

```
┌─────────────────────────────────┐
│       schema_migrations         │  ← Automatically managed by golang-migrate
│  (Migration record table)       │
│  version=2, dirty=0             │
└─────────────────────────────────┘
              │
              │ Records current version
              ▼
┌─────────────────────────────────┐
│     migrations/*.sql            │  ← Embedded via embed.FS
│  (Migration script files)       │
│  000001_initial.up.sql          │
│  000002_add_feature.up.sql      │
└─────────────────────────────────┘
              │
              │ Execute DDL/DML
              ▼
┌─────────────────────────────────┐
│     Business tables             │
│  connections, jobs, job_logs    │
└─────────────────────────────────┘
```

---

## Notes

1. **No ent entities required**: `schema_migrations` is automatically managed by golang-migrate and does not need to be defined in the ent schema.
2. **Migration files are immutable**: Once a migration is executed, existing migration file content cannot be modified.
3. **Version numbers must be sequential**: golang-migrate requires version numbers to increase consecutively.
4. **Automatic migration upgrade not supported**: Databases with business tables but no migration records will error out and require manual deletion by the user.
5. **Dirty state requires manual repair**: Manual intervention is required when `dirty=1`.